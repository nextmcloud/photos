(self["webpackChunkphotos"] = self["webpackChunkphotos"] || []).push([["vendors-node_modules_vue-virtual-grid_dist_virtual-grid_common_js"],{

/***/ "./node_modules/vue-virtual-grid/dist/virtual-grid.common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vue-virtual-grid/dist/virtual-grid.common.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

module.exports =
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __nested_webpack_require_6514__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_6514__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __nested_webpack_require_6514__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __nested_webpack_require_6514__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __nested_webpack_require_6514__.d = function (exports, name, getter) {
    /******/
    if (!__nested_webpack_require_6514__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __nested_webpack_require_6514__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __nested_webpack_require_6514__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __nested_webpack_require_6514__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __nested_webpack_require_6514__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __nested_webpack_require_6514__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __nested_webpack_require_6514__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __nested_webpack_require_6514__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __nested_webpack_require_6514__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __nested_webpack_require_6514__.p = "";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __nested_webpack_require_6514__(__nested_webpack_require_6514__.s = "fb15");
  /******/
}
/************************************************************************/

/******/
({
  /***/
  "24fb":
  /***/
  function fb(module, exports, __webpack_require__) {
    "use strict";
    /*
      MIT License http://www.opensource.org/licenses/mit-license.php
      Author Tobias Koppers @sokra
    */
    // css base code, injected by the css-loader
    // eslint-disable-next-line func-names

    module.exports = function (useSourceMap) {
      var list = []; // return the list of modules as css string

      list.toString = function toString() {
        return this.map(function (item) {
          var content = cssWithMappingToString(item, useSourceMap);

          if (item[2]) {
            return "@media ".concat(item[2], " {").concat(content, "}");
          }

          return content;
        }).join('');
      }; // import a list of modules into the list
      // eslint-disable-next-line func-names


      list.i = function (modules, mediaQuery, dedupe) {
        if (typeof modules === 'string') {
          // eslint-disable-next-line no-param-reassign
          modules = [[null, modules, '']];
        }

        var alreadyImportedModules = {};

        if (dedupe) {
          for (var i = 0; i < this.length; i++) {
            // eslint-disable-next-line prefer-destructuring
            var id = this[i][0];

            if (id != null) {
              alreadyImportedModules[id] = true;
            }
          }
        }

        for (var _i = 0; _i < modules.length; _i++) {
          var item = [].concat(modules[_i]);

          if (dedupe && alreadyImportedModules[item[0]]) {
            // eslint-disable-next-line no-continue
            continue;
          }

          if (mediaQuery) {
            if (!item[2]) {
              item[2] = mediaQuery;
            } else {
              item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
            }
          }

          list.push(item);
        }
      };

      return list;
    };

    function cssWithMappingToString(item, useSourceMap) {
      var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

      var cssMapping = item[3];

      if (!cssMapping) {
        return content;
      }

      if (useSourceMap && typeof btoa === 'function') {
        var sourceMapping = toComment(cssMapping);
        var sourceURLs = cssMapping.sources.map(function (source) {
          return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
        });
        return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
      }

      return [content].join('\n');
    } // Adapted from convert-source-map (MIT)


    function toComment(sourceMap) {
      // eslint-disable-next-line no-undef
      var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
      return "/*# ".concat(data, " */");
    }
    /***/

  },

  /***/
  "499e":
  /***/
  function e(module, __webpack_exports__, __nested_webpack_require_13489__) {
    "use strict"; // ESM COMPAT FLAG

    __nested_webpack_require_13489__.r(__webpack_exports__); // EXPORTS


    __nested_webpack_require_13489__.d(__webpack_exports__, "default", function () {
      return (
        /* binding */
        addStylesClient
      );
    }); // CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js

    /**
     * Translates the list format produced by css-loader into something
     * easier to manipulate.
     */


    function listToStyles(parentId, list) {
      var styles = [];
      var newStyles = {};

      for (var i = 0; i < list.length; i++) {
        var item = list[i];
        var id = item[0];
        var css = item[1];
        var media = item[2];
        var sourceMap = item[3];
        var part = {
          id: parentId + ':' + i,
          css: css,
          media: media,
          sourceMap: sourceMap
        };

        if (!newStyles[id]) {
          styles.push(newStyles[id] = {
            id: id,
            parts: [part]
          });
        } else {
          newStyles[id].parts.push(part);
        }
      }

      return styles;
    } // CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js

    /*
      MIT License http://www.opensource.org/licenses/mit-license.php
      Author Tobias Koppers @sokra
      Modified by Evan You @yyx990803
    */


    var hasDocument = typeof document !== 'undefined';

    if (typeof DEBUG !== 'undefined' && DEBUG) {
      if (!hasDocument) {
        throw new Error('vue-style-loader cannot be used in a non-browser environment. ' + "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
      }
    }
    /*
    type StyleObject = {
      id: number;
      parts: Array<StyleObjectPart>
    }
    
    type StyleObjectPart = {
      css: string;
      media: string;
      sourceMap: ?string
    }
    */


    var stylesInDom = {
      /*
      [id: number]: {
      id: number,
      refs: number,
      parts: Array<(obj?: StyleObjectPart) => void>
      }
      */
    };
    var head = hasDocument && (document.head || document.getElementsByTagName('head')[0]);
    var singletonElement = null;
    var singletonCounter = 0;
    var isProduction = false;

    var noop = function noop() {};

    var options = null;
    var ssrIdKey = 'data-vue-ssr-id'; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
    // tags it will allow on a page

    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());

    function addStylesClient(parentId, list, _isProduction, _options) {
      isProduction = _isProduction;
      options = _options || {};
      var styles = listToStyles(parentId, list);
      addStylesToDom(styles);
      return function update(newList) {
        var mayRemove = [];

        for (var i = 0; i < styles.length; i++) {
          var item = styles[i];
          var domStyle = stylesInDom[item.id];
          domStyle.refs--;
          mayRemove.push(domStyle);
        }

        if (newList) {
          styles = listToStyles(parentId, newList);
          addStylesToDom(styles);
        } else {
          styles = [];
        }

        for (var i = 0; i < mayRemove.length; i++) {
          var domStyle = mayRemove[i];

          if (domStyle.refs === 0) {
            for (var j = 0; j < domStyle.parts.length; j++) {
              domStyle.parts[j]();
            }

            delete stylesInDom[domStyle.id];
          }
        }
      };
    }

    function addStylesToDom(styles
    /* Array<StyleObject> */
    ) {
      for (var i = 0; i < styles.length; i++) {
        var item = styles[i];
        var domStyle = stylesInDom[item.id];

        if (domStyle) {
          domStyle.refs++;

          for (var j = 0; j < domStyle.parts.length; j++) {
            domStyle.parts[j](item.parts[j]);
          }

          for (; j < item.parts.length; j++) {
            domStyle.parts.push(addStyle(item.parts[j]));
          }

          if (domStyle.parts.length > item.parts.length) {
            domStyle.parts.length = item.parts.length;
          }
        } else {
          var parts = [];

          for (var j = 0; j < item.parts.length; j++) {
            parts.push(addStyle(item.parts[j]));
          }

          stylesInDom[item.id] = {
            id: item.id,
            refs: 1,
            parts: parts
          };
        }
      }
    }

    function createStyleElement() {
      var styleElement = document.createElement('style');
      styleElement.type = 'text/css';
      head.appendChild(styleElement);
      return styleElement;
    }

    function addStyle(obj
    /* StyleObjectPart */
    ) {
      var update, remove;
      var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]');

      if (styleElement) {
        if (isProduction) {
          // has SSR styles and in production mode.
          // simply do nothing.
          return noop;
        } else {
          // has SSR styles but in dev mode.
          // for some reason Chrome can't handle source map in server-rendered
          // style tags - source maps in <style> only works if the style tag is
          // created and inserted dynamically. So we remove the server rendered
          // styles and inject new ones.
          styleElement.parentNode.removeChild(styleElement);
        }
      }

      if (isOldIE) {
        // use singleton mode for IE9.
        var styleIndex = singletonCounter++;
        styleElement = singletonElement || (singletonElement = createStyleElement());
        update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
        remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
      } else {
        // use multi-style-tag mode in all other cases
        styleElement = createStyleElement();
        update = applyToTag.bind(null, styleElement);

        remove = function remove() {
          styleElement.parentNode.removeChild(styleElement);
        };
      }

      update(obj);
      return function updateStyle(newObj
      /* StyleObjectPart */
      ) {
        if (newObj) {
          if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
            return;
          }

          update(obj = newObj);
        } else {
          remove();
        }
      };
    }

    var replaceText = function () {
      var textStore = [];
      return function (index, replacement) {
        textStore[index] = replacement;
        return textStore.filter(Boolean).join('\n');
      };
    }();

    function applyToSingletonTag(styleElement, index, remove, obj) {
      var css = remove ? '' : obj.css;

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = replaceText(index, css);
      } else {
        var cssNode = document.createTextNode(css);
        var childNodes = styleElement.childNodes;
        if (childNodes[index]) styleElement.removeChild(childNodes[index]);

        if (childNodes.length) {
          styleElement.insertBefore(cssNode, childNodes[index]);
        } else {
          styleElement.appendChild(cssNode);
        }
      }
    }

    function applyToTag(styleElement, obj) {
      var css = obj.css;
      var media = obj.media;
      var sourceMap = obj.sourceMap;

      if (media) {
        styleElement.setAttribute('media', media);
      }

      if (options.ssrId) {
        styleElement.setAttribute(ssrIdKey, obj.id);
      }

      if (sourceMap) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';
      }

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = css;
      } else {
        while (styleElement.firstChild) {
          styleElement.removeChild(styleElement.firstChild);
        }

        styleElement.appendChild(document.createTextNode(css));
      }
    }
    /***/

  },

  /***/
  "8875":
  /***/
  function _(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // addapted from the document.currentScript polyfill by Adam Miller
    // MIT license
    // source: https://github.com/amiller-gh/currentScript-polyfill
    // added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505


    (function (root, factory) {
      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(typeof self !== 'undefined' ? self : this, function () {
      function getCurrentScript() {
        var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript'); // for chrome

        if (!descriptor && 'currentScript' in document && document.currentScript) {
          return document.currentScript;
        } // for other browsers with native support for currentScript


        if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
          return document.currentScript;
        } // IE 8-10 support script readyState
        // IE 11+ & Firefox support stack trace


        try {
          throw new Error();
        } catch (err) {
          // Find the second match for the "at" string to get file src url from stack.
          var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
              ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
              stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
              scriptLocation = stackDetails && stackDetails[1] || false,
              line = stackDetails && stackDetails[2] || false,
              currentLocation = document.location.href.replace(document.location.hash, ''),
              pageSource,
              inlineScriptSourceRegExp,
              inlineScriptSource,
              scripts = document.getElementsByTagName('script'); // Live NodeList collection

          if (scriptLocation === currentLocation) {
            pageSource = document.documentElement.outerHTML;
            inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
            inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
          }

          for (var i = 0; i < scripts.length; i++) {
            // If ready state is interactive, return the script tag
            if (scripts[i].readyState === 'interactive') {
              return scripts[i];
            } // If src matches, return the script tag


            if (scripts[i].src === scriptLocation) {
              return scripts[i];
            } // If inline source matches, return the script tag


            if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
              return scripts[i];
            }
          } // If no match, return null


          return null;
        }
      }

      ;
      return getCurrentScript;
    });
    /***/

  },

  /***/
  "8bbf":
  /***/
  function bbf(module, exports) {
    module.exports = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
    /***/
  },

  /***/
  "9e62":
  /***/
  function e62(module, exports, __nested_webpack_require_25360__) {
    // Imports
    var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_25360__("24fb");

    exports = ___CSS_LOADER_API_IMPORT___(false); // Module

    exports.push([module.i, ".grid[data-v-24e4d634]{display:grid;align-items:center}", ""]); // Exports

    module.exports = exports;
    /***/
  },

  /***/
  "c489":
  /***/
  function c489(module, __webpack_exports__, __nested_webpack_require_25749__) {
    "use strict";
    /* harmony import */

    var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VirtualGrid_vue_vue_type_style_index_0_id_24e4d634_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_25749__("c4cd");
    /* harmony import */


    var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VirtualGrid_vue_vue_type_style_index_0_id_24e4d634_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_25749__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VirtualGrid_vue_vue_type_style_index_0_id_24e4d634_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
    /* unused harmony reexport * */

    /***/

  },

  /***/
  "c4cd":
  /***/
  function c4cd(module, exports, __nested_webpack_require_27493__) {
    // style-loader: Adds some css to the DOM by adding a <style> tag
    // load the styles
    var content = __nested_webpack_require_27493__("9e62");

    if (content.__esModule) content = content.default;
    if (typeof content === 'string') content = [[module.i, content, '']];
    if (content.locals) module.exports = content.locals; // add the styles to the DOM

    var add = __nested_webpack_require_27493__("499e").default;

    var update = add("d08ad6f0", content, true, {
      "sourceMap": false,
      "shadowMode": false
    });
    /***/
  },

  /***/
  "fb15":
  /***/
  function fb15(module, __webpack_exports__, __nested_webpack_require_28122__) {
    "use strict"; // ESM COMPAT FLAG

    __nested_webpack_require_28122__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
    // This file is imported into lib/wc client bundles.


    if (typeof window !== 'undefined') {
      var currentScript = window.document.currentScript;

      if (true) {
        var getCurrentScript = __nested_webpack_require_28122__("8875");

        currentScript = getCurrentScript(); // for backward compatibility, because previously we directly included the polyfill

        if (!('currentScript' in document)) {
          Object.defineProperty(document, 'currentScript', {
            get: getCurrentScript
          });
        }
      }

      var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);

      if (src) {
        __nested_webpack_require_28122__.p = src[1]; // eslint-disable-line
      }
    } // Indicate to webpack that this file can be concatenated

    /* harmony default export */


    var setPublicPath = null; // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"15c5cc38-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VirtualGrid.vue?vue&type=template&id=24e4d634&scoped=true&

    var render = function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        ref: "virtualGrid",
        style: {
          boxSizing: 'border-box',
          height: _vm.layoutData.totalHeight + "px",
          paddingTop: "" + (_vm.renderData !== null && _vm.renderData.firstRenderedRowOffset !== null ? _vm.renderData.firstRenderedRowOffset + 'px' : '0px')
        }
      }, [_c('div', {
        staticClass: "grid",
        style: {
          'grid-template-columns': "repeat(" + _vm.configData.columnCount + ", 1fr)",
          'gap': _vm.configData.gridGap + "px"
        }
      }, _vm._l(_vm.renderData.cellsToRender, function (item) {
        return _c('div', {
          key: item.id,
          style: {
            'height': item.height,
            'grid-column-start': item.columnNumber,
            'grid-column-end': item.columnNumber + item.columnSpan,
            'grid-row-start': _vm.getGridRowStart(item, _vm.renderData)
          }
        }, [_c(item.renderComponent, _vm._g({
          tag: "component",
          attrs: {
            "item": item
          }
        }, _vm.$listeners))], 1);
      }), 0), _c(_vm.loadingBatch && _vm.loader, {
        tag: "component"
      })], 1);
    };

    var staticRenderFns = []; // CONCATENATED MODULE: ./src/VirtualGrid.vue?vue&type=template&id=24e4d634&scoped=true&
    // CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */

    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    function __rest(s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }

    function __decorate(decorators, target, key, desc) {
      var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof2(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    }

    function __metadata(metadataKey, metadataValue) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof2(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    function __createBinding(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    }

    function __exportStar(m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
    }

    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function next() {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
          r,
          ar = [],
          e;

      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
          ar.push(r.value);
        }
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }

      return ar;
    }

    function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
      }

      return ar;
    }

    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
      }

      for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
          r[k] = a[j];
        }
      }

      return r;
    }

    ;

    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i;

      function verb(n) {
        if (g[n]) i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }

      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }

      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }

      function fulfill(value) {
        resume("next", value);
      }

      function reject(value) {
        resume("throw", value);
      }

      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }

    function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function () {
        return this;
      }, i;

      function verb(n, f) {
        i[n] = o[n] ? function (v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: n === "return"
          } : f ? f(v) : v;
        } : f;
      }
    }

    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator],
          i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i);

      function verb(n) {
        i[n] = o[n] && function (v) {
          return new Promise(function (resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }

      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
          resolve({
            value: v,
            done: d
          });
        }, reject);
      }
    }

    function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
          value: raw
        });
      } else {
        cooked.raw = raw;
      }

      return cooked;
    }

    ;

    function __importStar(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      }
      result.default = mod;
      return result;
    }

    function __importDefault(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      privateMap.set(receiver, value);
      return value;
    } // EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}


    var external_commonjs_vue_commonjs2_vue_root_Vue_ = __nested_webpack_require_28122__("8bbf");

    var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__nested_webpack_require_28122__.n(external_commonjs_vue_commonjs2_vue_root_Vue_); // CONCATENATED MODULE: ./node_modules/vue-class-component/dist/vue-class-component.esm.js

    /**
      * vue-class-component v7.2.6
      * (c) 2015-present Evan You
      * @license MIT
      */


    function _typeof(obj) {
      if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
        _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };
      }

      return _typeof(obj);
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    } // The rational behind the verbose Reflect-feature check below is the fact that there are polyfills
    // which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.
    // Without this check consumers will encounter hard to track down runtime errors.


    function reflectionIsSupported() {
      return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;
    }

    function copyReflectionMetadata(to, from) {
      forwardMetadata(to, from);
      Object.getOwnPropertyNames(from.prototype).forEach(function (key) {
        forwardMetadata(to.prototype, from.prototype, key);
      });
      Object.getOwnPropertyNames(from).forEach(function (key) {
        forwardMetadata(to, from, key);
      });
    }

    function forwardMetadata(to, from, propertyKey) {
      var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);
      metaKeys.forEach(function (metaKey) {
        var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);

        if (propertyKey) {
          Reflect.defineMetadata(metaKey, metadata, to, propertyKey);
        } else {
          Reflect.defineMetadata(metaKey, metadata, to);
        }
      });
    }

    var fakeArray = {
      __proto__: []
    };
    var hasProto = fakeArray instanceof Array;

    function createDecorator(factory) {
      return function (target, key, index) {
        var Ctor = typeof target === 'function' ? target : target.constructor;

        if (!Ctor.__decorators__) {
          Ctor.__decorators__ = [];
        }

        if (typeof index !== 'number') {
          index = undefined;
        }

        Ctor.__decorators__.push(function (options) {
          return factory(options, key, index);
        });
      };
    }

    function mixins() {
      for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {
        Ctors[_key] = arguments[_key];
      }

      return external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
        mixins: Ctors
      });
    }

    function isPrimitive(value) {
      var type = _typeof(value);

      return value == null || type !== 'object' && type !== 'function';
    }

    function warn(message) {
      if (typeof console !== 'undefined') {
        console.warn('[vue-class-component] ' + message);
      }
    }

    function collectDataFromConstructor(vm, Component) {
      // override _init to prevent to init as Vue instance
      var originalInit = Component.prototype._init;

      Component.prototype._init = function () {
        var _this = this; // proxy to actual vm


        var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)

        if (vm.$options.props) {
          for (var key in vm.$options.props) {
            if (!vm.hasOwnProperty(key)) {
              keys.push(key);
            }
          }
        }

        keys.forEach(function (key) {
          Object.defineProperty(_this, key, {
            get: function get() {
              return vm[key];
            },
            set: function set(value) {
              vm[key] = value;
            },
            configurable: true
          });
        });
      }; // should be acquired class property values


      var data = new Component(); // restore original _init to avoid memory leak (#209)

      Component.prototype._init = originalInit; // create plain data object

      var plainData = {};
      Object.keys(data).forEach(function (key) {
        if (data[key] !== undefined) {
          plainData[key] = data[key];
        }
      });

      if (false) {}

      return plainData;
    }

    var $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6
    ];

    function componentFactory(Component) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options.name = options.name || Component._componentTag || Component.name; // prototype props.

      var proto = Component.prototype;
      Object.getOwnPropertyNames(proto).forEach(function (key) {
        if (key === 'constructor') {
          return;
        } // hooks


        if ($internalHooks.indexOf(key) > -1) {
          options[key] = proto[key];
          return;
        }

        var descriptor = Object.getOwnPropertyDescriptor(proto, key);

        if (descriptor.value !== void 0) {
          // methods
          if (typeof descriptor.value === 'function') {
            (options.methods || (options.methods = {}))[key] = descriptor.value;
          } else {
            // typescript decorated data
            (options.mixins || (options.mixins = [])).push({
              data: function data() {
                return _defineProperty({}, key, descriptor.value);
              }
            });
          }
        } else if (descriptor.get || descriptor.set) {
          // computed properties
          (options.computed || (options.computed = {}))[key] = {
            get: descriptor.get,
            set: descriptor.set
          };
        }
      });
      (options.mixins || (options.mixins = [])).push({
        data: function data() {
          return collectDataFromConstructor(this, Component);
        }
      }); // decorate options

      var decorators = Component.__decorators__;

      if (decorators) {
        decorators.forEach(function (fn) {
          return fn(options);
        });
        delete Component.__decorators__;
      } // find super


      var superProto = Object.getPrototypeOf(Component.prototype);
      var Super = superProto instanceof external_commonjs_vue_commonjs2_vue_root_Vue_default.a ? superProto.constructor : external_commonjs_vue_commonjs2_vue_root_Vue_default.a;
      var Extended = Super.extend(options);
      forwardStaticMembers(Extended, Component, Super);

      if (reflectionIsSupported()) {
        copyReflectionMetadata(Extended, Component);
      }

      return Extended;
    }

    var reservedPropertyNames = [// Unique id
    'cid', // Super Vue constructor
    'super', // Component options that will be used by the component
    'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets
    'component', 'directive', 'filter'];
    var shouldIgnore = {
      prototype: true,
      arguments: true,
      callee: true,
      caller: true
    };

    function forwardStaticMembers(Extended, Original, Super) {
      // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable
      Object.getOwnPropertyNames(Original).forEach(function (key) {
        // Skip the properties that should not be overwritten
        if (shouldIgnore[key]) {
          return;
        } // Some browsers does not allow reconfigure built-in properties


        var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);

        if (extendedDescriptor && !extendedDescriptor.configurable) {
          return;
        }

        var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),
        // the sub class properties may be inherited properties from the super class in TypeScript.
        // We need to exclude such properties to prevent to overwrite
        // the component options object which stored on the extended constructor (See #192).
        // If the value is a referenced value (object or function),
        // we can check equality of them and exclude it if they have the same reference.
        // If it is a primitive value, it will be forwarded for safety.

        if (!hasProto) {
          // Only `cid` is explicitly exluded from property forwarding
          // because we cannot detect whether it is a inherited property or not
          // on the no `__proto__` environment even though the property is reserved.
          if (key === 'cid') {
            return;
          }

          var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);

          if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {
            return;
          }
        } // Warn if the users manually declare reserved properties


        if (false) {}

        Object.defineProperty(Extended, key, descriptor);
      });
    }

    function vue_class_component_esm_Component(options) {
      if (typeof options === 'function') {
        return componentFactory(options);
      }

      return function (Component) {
        return componentFactory(Component, options);
      };
    }

    vue_class_component_esm_Component.registerHooks = function registerHooks(keys) {
      $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));
    };
    /* harmony default export */


    var vue_class_component_esm = vue_class_component_esm_Component; // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Emit.js

    var Emit_spreadArrays = undefined && undefined.__spreadArrays || function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
      }

      for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
          r[k] = a[j];
        }
      }

      return r;
    }; // Code copied from Vue/src/shared/util.js


    var hyphenateRE = /\B([A-Z])/g;

    var hyphenate = function hyphenate(str) {
      return str.replace(hyphenateRE, '-$1').toLowerCase();
    };
    /**
     * decorator of an event-emitter function
     * @param  event The name of the event
     * @return MethodDecorator
     */


    function Emit(event) {
      return function (_target, propertyKey, descriptor) {
        var key = hyphenate(propertyKey);
        var original = descriptor.value;

        descriptor.value = function emitter() {
          var _this = this;

          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          var emit = function emit(returnValue) {
            var emitName = event || key;

            if (returnValue === undefined) {
              if (args.length === 0) {
                _this.$emit(emitName);
              } else if (args.length === 1) {
                _this.$emit(emitName, args[0]);
              } else {
                _this.$emit.apply(_this, Emit_spreadArrays([emitName], args));
              }
            } else {
              args.unshift(returnValue);

              _this.$emit.apply(_this, Emit_spreadArrays([emitName], args));
            }
          };

          var returnValue = original.apply(this, args);

          if (isPromise(returnValue)) {
            returnValue.then(emit);
          } else {
            emit(returnValue);
          }

          return returnValue;
        };
      };
    }

    function isPromise(obj) {
      return obj instanceof Promise || obj && typeof obj.then === 'function';
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Inject.js

    /**
     * decorator of an inject
     * @param from key
     * @return PropertyDecorator
     */


    function Inject(options) {
      return createDecorator(function (componentOptions, key) {
        if (typeof componentOptions.inject === 'undefined') {
          componentOptions.inject = {};
        }

        if (!Array.isArray(componentOptions.inject)) {
          componentOptions.inject[key] = options || key;
        }
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/helpers/provideInject.js


    function needToProduceProvide(original) {
      return typeof original !== 'function' || !original.managed && !original.managedReactive;
    }

    function produceProvide(original) {
      var provide = function provide() {
        var _this = this;

        var rv = typeof original === 'function' ? original.call(this) : original;
        rv = Object.create(rv || null); // set reactive services (propagates previous services if necessary)

        rv[reactiveInjectKey] = Object.create(this[reactiveInjectKey] || {});

        for (var i in provide.managed) {
          rv[provide.managed[i]] = this[i];
        }

        var _loop_1 = function _loop_1(i) {
          rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`

          Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {
            enumerable: true,
            configurable: true,
            get: function get() {
              return _this[i];
            }
          });
        };

        var this_1 = this;

        for (var i in provide.managedReactive) {
          _loop_1(i);
        }

        return rv;
      };

      provide.managed = {};
      provide.managedReactive = {};
      return provide;
    }
    /** Used for keying reactive provide/inject properties */


    var reactiveInjectKey = '__reactiveInject__';

    function inheritInjected(componentOptions) {
      // inject parent reactive services (if any)
      if (!Array.isArray(componentOptions.inject)) {
        componentOptions.inject = componentOptions.inject || {};
        componentOptions.inject[reactiveInjectKey] = {
          from: reactiveInjectKey,
          default: {}
        };
      }
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/InjectReactive.js

    /**
     * decorator of a reactive inject
     * @param from key
     * @return PropertyDecorator
     */


    function InjectReactive(options) {
      return createDecorator(function (componentOptions, key) {
        if (typeof componentOptions.inject === 'undefined') {
          componentOptions.inject = {};
        }

        if (!Array.isArray(componentOptions.inject)) {
          var fromKey_1 = !!options ? options.from || options : key;
          var defaultVal_1 = !!options && options.default || undefined;
          if (!componentOptions.computed) componentOptions.computed = {};

          componentOptions.computed[key] = function () {
            var obj = this[reactiveInjectKey];
            return obj ? obj[fromKey_1] : defaultVal_1;
          };

          componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;
        }
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/helpers/metadata.js

    /** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */


    var reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';

    function applyMetadata(options, target, key) {
      if (reflectMetadataIsSupported) {
        if (!Array.isArray(options) && typeof options !== 'function' && !options.hasOwnProperty('type') && typeof options.type === 'undefined') {
          var type = Reflect.getMetadata('design:type', target, key);

          if (type !== Object) {
            options.type = type;
          }
        }
      }
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Model.js

    /**
     * decorator of model
     * @param  event event name
     * @param options options
     * @return PropertyDecorator
     */


    function Model(event, options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[k] = options;
          componentOptions.model = {
            prop: k,
            event: event || k
          };
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/ModelSync.js

    /**
     * decorator of synced model and prop
     * @param propName the name to interface with from outside, must be different from decorated property
     * @param  event event name
     * @param options options
     * @return PropertyDecorator
     */


    function ModelSync(propName, event, options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[propName] = options;
          componentOptions.model = {
            prop: propName,
            event: event || k
          };
          (componentOptions.computed || (componentOptions.computed = {}))[k] = {
            get: function get() {
              return this[propName];
            },
            set: function set(value) {
              // @ts-ignore
              this.$emit(event, value);
            }
          };
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Prop.js

    /**
     * decorator of a prop
     * @param  options the options for the prop
     * @return PropertyDecorator | void
     */


    function Prop(options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[k] = options;
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/PropSync.js

    /**
     * decorator of a synced prop
     * @param propName the name to interface with from outside, must be different from decorated property
     * @param options the options for the synced prop
     * @return PropertyDecorator | void
     */


    function PropSync(propName, options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[propName] = options;
          (componentOptions.computed || (componentOptions.computed = {}))[k] = {
            get: function get() {
              return this[propName];
            },
            set: function set(value) {
              this.$emit("update:" + propName, value);
            }
          };
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Provide.js

    /**
     * decorator of a provide
     * @param key key
     * @return PropertyDecorator | void
     */


    function Provide(key) {
      return createDecorator(function (componentOptions, k) {
        var provide = componentOptions.provide;
        inheritInjected(componentOptions);

        if (needToProduceProvide(provide)) {
          provide = componentOptions.provide = produceProvide(provide);
        }

        provide.managed[k] = key || k;
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/ProvideReactive.js

    /**
     * decorator of a reactive provide
     * @param key key
     * @return PropertyDecorator | void
     */


    function ProvideReactive(key) {
      return createDecorator(function (componentOptions, k) {
        var provide = componentOptions.provide;
        inheritInjected(componentOptions);

        if (needToProduceProvide(provide)) {
          provide = componentOptions.provide = produceProvide(provide);
        }

        provide.managedReactive[k] = key || k;
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Ref.js

    /**
     * decorator of a ref prop
     * @param refKey the ref key defined in template
     */


    function Ref(refKey) {
      return createDecorator(function (options, key) {
        options.computed = options.computed || {};
        options.computed[key] = {
          cache: false,
          get: function get() {
            return this.$refs[refKey || key];
          }
        };
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/VModel.js

    /**
     * decorator for capturings v-model binding to component
     * @param options the options for the prop
     */


    function VModel(options) {
      if (options === void 0) {
        options = {};
      }

      var valueKey = 'value';
      return createDecorator(function (componentOptions, key) {
        ;
        (componentOptions.props || (componentOptions.props = {}))[valueKey] = options;
        (componentOptions.computed || (componentOptions.computed = {}))[key] = {
          get: function get() {
            return this[valueKey];
          },
          set: function set(value) {
            this.$emit('input', value);
          }
        };
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Watch.js

    /**
     * decorator of a watch function
     * @param  path the path or the expression to observe
     * @param  WatchOption
     * @return MethodDecorator
     */


    function Watch(path, options) {
      if (options === void 0) {
        options = {};
      }

      var _a = options.deep,
          deep = _a === void 0 ? false : _a,
          _b = options.immediate,
          immediate = _b === void 0 ? false : _b;
      return createDecorator(function (componentOptions, handler) {
        if (_typeof2(componentOptions.watch) !== 'object') {
          componentOptions.watch = Object.create(null);
        }

        var watch = componentOptions.watch;

        if (_typeof2(watch[path]) === 'object' && !Array.isArray(watch[path])) {
          watch[path] = [watch[path]];
        } else if (typeof watch[path] === 'undefined') {
          watch[path] = [];
        }

        watch[path].push({
          handler: handler,
          deep: deep,
          immediate: immediate
        });
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/index.js

    /** vue-property-decorator verson 9.1.2 MIT LICENSE copyright 2020 kaorun343 */
    /// <reference types='reflect-metadata'/>
    // CONCATENATED MODULE: ./src/utils.ts


    var getGridGapDefault = function getGridGapDefault(elementWidth, windowHeight) {
      if (elementWidth > 720 && windowHeight > 480) {
        return 10;
      } else {
        return 5;
      }
    };

    var getColumnCountDefault = function getColumnCountDefault(elementWidth) {
      return Math.floor(elementWidth / 250);
    };

    var getWindowMarginDefault = function getWindowMarginDefault(windowHeight) {
      return Math.round(windowHeight * 1.5);
    };

    var getItemRatioHeightDefault = function getItemRatioHeightDefault(height, width, columnWidth) {
      var imageRatio = height / width;
      return Math.round(columnWidth * imageRatio);
    };

    var debugLog = function debugLog(condition) {
      if (condition) {
        var _console;

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        (_console = console).debug.apply(_console, args);
      }
    }; // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/ts-loader??ref--13-2!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VirtualGrid.vue?vue&type=script&lang=ts&


    var VirtualGridvue_type_script_lang_ts_a, VirtualGridvue_type_script_lang_ts_b;

    var VirtualGridvue_type_script_lang_ts_VirtualGrid = /*#__PURE__*/function (_external_commonjs_vu) {
      _inherits(VirtualGrid, _external_commonjs_vu);

      var _super = _createSuper(VirtualGrid);

      function VirtualGrid() {
        var _this2;

        _classCallCheck(this, VirtualGrid);

        _this2 = _super.apply(this, arguments);
        _this2.updateLock = false;
        _this2.bottomReached = false;
        _this2.ref = null;
        _this2.containerData = {
          windowSize: {
            height: 0,
            width: 0
          },
          windowScroll: {
            x: 0,
            y: 0
          },
          elementWindowOffset: 0,
          elementSize: {
            height: 0,
            width: 0
          }
        };
        return _this2;
      }

      _createClass(VirtualGrid, [{
        key: "loadingBatch",
        get: function get() {
          return this.loader && this.updateLock;
        }
      }, {
        key: "configData",
        get: function get() {
          return this.computeConfigData(this.containerData, this.items);
        }
      }, {
        key: "layoutData",
        get: function get() {
          return this.computeLayoutData(this.configData);
        }
      }, {
        key: "renderData",
        get: function get() {
          return this.computeRenderData(this.configData, this.containerData, this.layoutData);
        }
      }, {
        key: "mounted",
        value: function mounted() {
          this.ref = this.$refs.virtualGrid;
          this.initiliazeGrid();
          window.addEventListener('resize', this.resize);
          window.addEventListener('scroll', this.scroll);
        }
      }, {
        key: "beforeDestroy",
        value: function beforeDestroy() {
          window.removeEventListener('resize', this.resize);
          window.removeEventListener('scroll', this.scroll);
        }
      }, {
        key: "resize",
        value: function resize() {
          this.loadMoreData();
        }
      }, {
        key: "scroll",
        value: function scroll() {
          this.loadMoreData();
        }
      }, {
        key: "initiliazeGrid",
        value: function initiliazeGrid() {
          var _this3 = this;

          this.computeContainerData();
          this.$nextTick( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this3.loadMoreData();

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          })));
        }
      }, {
        key: "loadMoreData",
        value: function loadMoreData() {
          this.loadMoreDataAsync().catch(function (error) {
            if (error) {
              console.error('Fail to load next data batch', error);
            }
          }).then();
        }
      }, {
        key: "loadMoreDataAsync",
        value: function () {
          var _loadMoreDataAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var windowTop, windowBottom, bottomTrigger, isLastBatch;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this.computeContainerData();
                    windowTop = this.containerData.windowScroll.y;
                    windowBottom = windowTop + this.containerData.windowSize.height;
                    bottomTrigger = Math.max(0, this.containerData.elementWindowOffset + this.containerData.elementSize.height - this.updateTriggerMargin);

                    if (!(!this.bottomReached && windowBottom >= bottomTrigger && !this.updateLock)) {
                      _context2.next = 14;
                      break;
                    }

                    this.updateLock = true;
                    debugLog(this.debug, 'Loading next batch');
                    _context2.next = 9;
                    return this.updateFunction();

                  case 9:
                    isLastBatch = _context2.sent;

                    if (isLastBatch) {
                      debugLog(this.debug, 'Bottom reached');
                      this.bottomReached = true;
                    }

                    this.updateLock = false;
                    _context2.next = 14;
                    return this.loadMoreDataAsync();

                  case 14:
                    return _context2.abrupt("return");

                  case 15:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function loadMoreDataAsync() {
            return _loadMoreDataAsync.apply(this, arguments);
          }

          return loadMoreDataAsync;
        }()
      }, {
        key: "computeContainerData",
        value: function computeContainerData() {
          if (this.ref === null) {
            return;
          }

          var windowSize = this.getWindowSize();
          var windowScroll = this.getWindowScroll();
          var elementWindowOffset = this.getElementOffset(this.ref);
          var elementSize = this.getElementSize(this.ref);
          this.containerData = {
            windowSize: windowSize,
            windowScroll: windowScroll,
            elementWindowOffset: elementWindowOffset,
            elementSize: elementSize
          };
        }
      }, {
        key: "computeConfigData",
        value: function computeConfigData(containerData, items) {
          var _this4 = this;

          if (containerData === null || items === null) {
            return {
              windowMargin: 0,
              gridGap: 0,
              columnCount: 1,
              entries: []
            };
          }

          var elementWidth = containerData.elementSize ? containerData.elementSize.width : null;
          var windowMargin = this.getWindowMargin(containerData.windowSize.height);
          var gridGap = this.getGridGap(elementWidth, containerData.windowSize.height);
          var columnCount = this.getColumnCount(elementWidth);
          var columnWidth = this.getColumnWidth(columnCount, gridGap, elementWidth);
          var entries = items.map(function (item) {
            if (!item.width) {
              return item;
            }

            var imageWidth = columnWidth * item.columnSpan + gridGap * (item.columnSpan - 1);
            return _objectSpread(_objectSpread({}, item), {}, {
              height: _this4.getItemRatioHeight(item.height, item.width, imageWidth),
              width: imageWidth
            });
          });
          return {
            windowMargin: windowMargin,
            gridGap: gridGap,
            columnCount: columnCount,
            entries: entries
          };
        }
      }, {
        key: "computeLayoutData",
        value: function computeLayoutData(configData) {
          if (configData === null) {
            return {
              cells: [],
              totalHeight: 0
            };
          }

          var currentRowNumber = 1;
          var prevRowsTotalHeight = 0;
          var currentRowMaxHeight = 0;
          var columnShift = 0;
          var cells = configData.entries.map(function (entry, index) {
            var columnCount = configData.columnCount,
                gridGap = configData.gridGap;
            var columnSpanRecompute = entry.columnSpan;
            var heightRecompute = entry.height;

            if (columnSpanRecompute < 1) {
              columnSpanRecompute = columnCount;
            }

            var distanceToRowStart = (index + columnShift) % columnCount;

            if (entry.newRow && distanceToRowStart !== 0) {
              columnShift += columnCount - distanceToRowStart;
            }

            var shiftedIndex = index + columnShift;
            var columnNumber = shiftedIndex % columnCount + 1;
            var rowNumber = Math.floor(shiftedIndex / columnCount) + 1;

            if (columnNumber + columnSpanRecompute > columnCount + 1) {
              var overlapNumber = columnNumber + columnSpanRecompute - columnCount - 1;
              var overlapRatio = overlapNumber / columnSpanRecompute;
              heightRecompute = heightRecompute * (1 - overlapRatio);
              columnSpanRecompute -= overlapNumber;
            }

            if (columnSpanRecompute > 1) {
              columnShift += columnSpanRecompute - 1;
            }

            if (rowNumber !== currentRowNumber) {
              currentRowNumber = rowNumber;
              prevRowsTotalHeight += currentRowMaxHeight + gridGap;
              currentRowMaxHeight = 0;
            }

            var offset = prevRowsTotalHeight;
            var height = Math.round(heightRecompute);
            currentRowMaxHeight = Math.max(currentRowMaxHeight, height);
            return _objectSpread(_objectSpread({}, entry), {}, {
              columnNumber: columnNumber,
              rowNumber: rowNumber,
              offset: offset,
              height: height,
              columnSpan: columnSpanRecompute
            });
          });
          var totalHeight = prevRowsTotalHeight + currentRowMaxHeight;
          return {
            cells: cells,
            totalHeight: totalHeight
          };
        }
      }, {
        key: "computeRenderData",
        value: function computeRenderData(configData, containerData, layoutData) {
          if (layoutData === null || configData === null) {
            return {
              cellsToRender: [],
              firstRenderedRowNumber: 0,
              firstRenderedRowOffset: 0
            };
          }

          var cellsToRender = [];
          var firstRenderedRowNumber = null;
          var firstRenderedRowOffset = null;

          if (containerData.elementWindowOffset !== null) {
            var elementWindowOffset = containerData.elementWindowOffset;

            var _iterator = _createForOfIteratorHelper(layoutData.cells),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var cell = _step.value;
                var cellTop = elementWindowOffset + cell.offset;
                var cellBottom = cellTop + cell.height;
                var windowTop = containerData.windowScroll.y;
                var windowBottom = windowTop + containerData.windowSize.height;
                var renderTop = windowTop - configData.windowMargin;
                var renderBottom = windowBottom + configData.windowMargin;

                if (cellTop > renderBottom) {
                  continue;
                }

                if (cellBottom < renderTop) {
                  continue;
                }

                if (firstRenderedRowNumber === null) {
                  firstRenderedRowNumber = cell.rowNumber;
                }

                if (cell.rowNumber === firstRenderedRowNumber) {
                  firstRenderedRowOffset = firstRenderedRowOffset ? Math.min(firstRenderedRowOffset, cell.offset) : cell.offset;
                }

                cellsToRender.push(cell);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }

          return {
            cellsToRender: cellsToRender,
            firstRenderedRowNumber: firstRenderedRowNumber,
            firstRenderedRowOffset: firstRenderedRowOffset
          };
        }
      }, {
        key: "getColumnWidth",
        value: function getColumnWidth(columnCount, gridGap, elementWidth) {
          if (columnCount === null || gridGap === null || elementWidth === null) {
            return null;
          }

          var totalGapSpace = (columnCount - 1) * gridGap;
          var columnWidth = Math.round((elementWidth - totalGapSpace) / columnCount);
          return columnWidth;
        }
      }, {
        key: "getGridRowStart",
        value: function getGridRowStart(cell, renderData) {
          if (renderData === null) {
            return undefined;
          }

          var offset = renderData.firstRenderedRowNumber !== null ? renderData.firstRenderedRowNumber - 1 : 0;
          var gridRowStart = cell.rowNumber - offset;
          return "".concat(gridRowStart);
        }
      }, {
        key: "resetGrid",
        value: function resetGrid() {
          this.bottomReached = false;
          this.loadMoreData();
        }
      }, {
        key: "isSameElementSize",
        value: function isSameElementSize(a, b) {
          return a.width === b.width && a.height === b.height;
        }
      }, {
        key: "getWindowSize",
        value: function getWindowSize() {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        }
      }, {
        key: "getElementSize",
        value: function getElementSize(element) {
          var rect = element.getBoundingClientRect();
          return {
            width: rect.width,
            height: rect.height
          };
        }
      }, {
        key: "isSameElementScroll",
        value: function isSameElementScroll(a, b) {
          return a.x === b.x && a.y === b.y;
        }
      }, {
        key: "getWindowScroll",
        value: function getWindowScroll() {
          return {
            x: window.scrollX,
            y: window.scrollY
          };
        }
      }, {
        key: "getElementOffset",
        value: function getElementOffset(element) {
          return window.scrollY + element.getBoundingClientRect().top;
        }
      }]);

      return VirtualGrid;
    }(external_commonjs_vue_commonjs2_vue_root_Vue_default.a);

    __decorate([Prop({
      required: true
    }), __metadata("design:type", Array)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "items", void 0);

    __decorate([Prop({
      default: function _default() {
        return function () {
          return true;
        };
      }
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "updateFunction", void 0);

    __decorate([Prop({
      default: function _default() {
        return getGridGapDefault;
      }
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getGridGap", void 0);

    __decorate([Prop({
      default: function _default() {
        return getColumnCountDefault;
      }
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getColumnCount", void 0);

    __decorate([Prop({
      default: function _default() {
        return getWindowMarginDefault;
      }
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getWindowMargin", void 0);

    __decorate([Prop({
      default: function _default() {
        return getItemRatioHeightDefault;
      }
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getItemRatioHeight", void 0);

    __decorate([Prop({
      default: 500
    }), __metadata("design:type", Number)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "updateTriggerMargin", void 0);

    __decorate([Prop({
      default: null
    }), __metadata("design:type", typeof (VirtualGridvue_type_script_lang_ts_a = typeof external_commonjs_vue_commonjs2_vue_root_Vue_default.a !== "undefined" && external_commonjs_vue_commonjs2_vue_root_Vue_default.a.Component) === "function" ? VirtualGridvue_type_script_lang_ts_a : Object)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "loader", void 0);

    __decorate([Prop({
      default: false
    }), __metadata("design:type", Boolean)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "debug", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", Boolean)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "updateLock", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", Boolean)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "bottomReached", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", typeof (VirtualGridvue_type_script_lang_ts_b = typeof Element !== "undefined" && Element) === "function" ? VirtualGridvue_type_script_lang_ts_b : Object)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "ref", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", Object)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "containerData", void 0);

    VirtualGridvue_type_script_lang_ts_VirtualGrid = __decorate([vue_class_component_esm], VirtualGridvue_type_script_lang_ts_VirtualGrid);
    /* harmony default export */

    var VirtualGridvue_type_script_lang_ts_ = VirtualGridvue_type_script_lang_ts_VirtualGrid; // CONCATENATED MODULE: ./src/VirtualGrid.vue?vue&type=script&lang=ts&

    /* harmony default export */

    var src_VirtualGridvue_type_script_lang_ts_ = VirtualGridvue_type_script_lang_ts_; // EXTERNAL MODULE: ./src/VirtualGrid.vue?vue&type=style&index=0&id=24e4d634&scoped=true&lang=css&

    var VirtualGridvue_type_style_index_0_id_24e4d634_scoped_true_lang_css_ = __nested_webpack_require_28122__("c489"); // CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js

    /* globals __VUE_SSR_CONTEXT__ */
    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
    // This module is a runtime utility for cleaner component module output and will
    // be included in the final webpack user bundle.


    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier,
    /* server only */
    shadowMode
    /* vue-cli only */
    ) {
      // Vue.extend constructor export interop
      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports; // render functions

      if (render) {
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        options._compiled = true;
      } // functional template


      if (functionalTemplate) {
        options.functional = true;
      } // scopedId


      if (scopeId) {
        options._scopeId = 'data-v-' + scopeId;
      }

      var hook;

      if (moduleIdentifier) {
        // server build
        hook = function hook(context) {
          // 2.3 injection
          context = context || // cached call
          this.$vnode && this.$vnode.ssrContext || // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true

          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          } // inject component styles


          if (injectStyles) {
            injectStyles.call(this, context);
          } // register component module identifier for async chunk inferrence


          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        }; // used by ssr in case component is cached and beforeCreate
        // never gets called


        options._ssrRegister = hook;
      } else if (injectStyles) {
        hook = shadowMode ? function () {
          injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
        } : injectStyles;
      }

      if (hook) {
        if (options.functional) {
          // for template-only hot-reload because in that case the render fn doesn't
          // go through the normalizer
          options._injectStyles = hook; // register for functional component in vue file

          var originalRender = options.render;

          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }

      return {
        exports: scriptExports,
        options: options
      };
    } // CONCATENATED MODULE: ./src/VirtualGrid.vue

    /* normalize component */


    var component = normalizeComponent(src_VirtualGridvue_type_script_lang_ts_, render, staticRenderFns, false, null, "24e4d634", null);
    /* harmony default export */

    var src_VirtualGrid = component.exports; // CONCATENATED MODULE: ./src/main.ts

    /* harmony default export */

    var main = src_VirtualGrid; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

    /* harmony default export */

    var entry_lib = __webpack_exports__["default"] = main;
    /***/
  }
  /******/

});

/***/ })

}]);
//# sourceMappingURL=photos-vendors-node_modules_vue-virtual-grid_dist_virtual-grid_common_js.js.map?v=b864f39532d06fe1978a