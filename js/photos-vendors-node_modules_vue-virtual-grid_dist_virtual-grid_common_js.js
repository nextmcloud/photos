(self["webpackChunkphotos"] = self["webpackChunkphotos"] || []).push([["vendors-node_modules_vue-virtual-grid_dist_virtual-grid_common_js"],{

/***/ "./node_modules/vue-virtual-grid/dist/virtual-grid.common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vue-virtual-grid/dist/virtual-grid.common.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
module.exports =
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __nested_webpack_require_208__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_208__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __nested_webpack_require_208__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __nested_webpack_require_208__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __nested_webpack_require_208__.d = function (exports, name, getter) {
    /******/
    if (!__nested_webpack_require_208__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __nested_webpack_require_208__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __nested_webpack_require_208__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __nested_webpack_require_208__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __nested_webpack_require_208__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_208__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __nested_webpack_require_208__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __nested_webpack_require_208__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __nested_webpack_require_208__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __nested_webpack_require_208__.p = "";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __nested_webpack_require_208__(__nested_webpack_require_208__.s = "fb15");
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "24fb":
  /***/
  function (module, exports, __webpack_require__) {
    "use strict";
    /*
      MIT License http://www.opensource.org/licenses/mit-license.php
      Author Tobias Koppers @sokra
    */
    // css base code, injected by the css-loader
    // eslint-disable-next-line func-names

    module.exports = function (useSourceMap) {
      var list = []; // return the list of modules as css string

      list.toString = function toString() {
        return this.map(function (item) {
          var content = cssWithMappingToString(item, useSourceMap);

          if (item[2]) {
            return "@media ".concat(item[2], " {").concat(content, "}");
          }

          return content;
        }).join('');
      }; // import a list of modules into the list
      // eslint-disable-next-line func-names


      list.i = function (modules, mediaQuery, dedupe) {
        if (typeof modules === 'string') {
          // eslint-disable-next-line no-param-reassign
          modules = [[null, modules, '']];
        }

        var alreadyImportedModules = {};

        if (dedupe) {
          for (var i = 0; i < this.length; i++) {
            // eslint-disable-next-line prefer-destructuring
            var id = this[i][0];

            if (id != null) {
              alreadyImportedModules[id] = true;
            }
          }
        }

        for (var _i = 0; _i < modules.length; _i++) {
          var item = [].concat(modules[_i]);

          if (dedupe && alreadyImportedModules[item[0]]) {
            // eslint-disable-next-line no-continue
            continue;
          }

          if (mediaQuery) {
            if (!item[2]) {
              item[2] = mediaQuery;
            } else {
              item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
            }
          }

          list.push(item);
        }
      };

      return list;
    };

    function cssWithMappingToString(item, useSourceMap) {
      var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

      var cssMapping = item[3];

      if (!cssMapping) {
        return content;
      }

      if (useSourceMap && typeof btoa === 'function') {
        var sourceMapping = toComment(cssMapping);
        var sourceURLs = cssMapping.sources.map(function (source) {
          return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
        });
        return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
      }

      return [content].join('\n');
    } // Adapted from convert-source-map (MIT)


    function toComment(sourceMap) {
      // eslint-disable-next-line no-undef
      var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
      return "/*# ".concat(data, " */");
    }
    /***/

  },

  /***/
  "499e":
  /***/
  function (module, __webpack_exports__, __nested_webpack_require_7159__) {
    "use strict"; // ESM COMPAT FLAG

    __nested_webpack_require_7159__.r(__webpack_exports__); // EXPORTS


    __nested_webpack_require_7159__.d(__webpack_exports__, "default", function () {
      return (
        /* binding */
        addStylesClient
      );
    }); // CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js

    /**
     * Translates the list format produced by css-loader into something
     * easier to manipulate.
     */


    function listToStyles(parentId, list) {
      var styles = [];
      var newStyles = {};

      for (var i = 0; i < list.length; i++) {
        var item = list[i];
        var id = item[0];
        var css = item[1];
        var media = item[2];
        var sourceMap = item[3];
        var part = {
          id: parentId + ':' + i,
          css: css,
          media: media,
          sourceMap: sourceMap
        };

        if (!newStyles[id]) {
          styles.push(newStyles[id] = {
            id: id,
            parts: [part]
          });
        } else {
          newStyles[id].parts.push(part);
        }
      }

      return styles;
    } // CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js

    /*
      MIT License http://www.opensource.org/licenses/mit-license.php
      Author Tobias Koppers @sokra
      Modified by Evan You @yyx990803
    */


    var hasDocument = typeof document !== 'undefined';

    if (typeof DEBUG !== 'undefined' && DEBUG) {
      if (!hasDocument) {
        throw new Error('vue-style-loader cannot be used in a non-browser environment. ' + "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
      }
    }
    /*
    type StyleObject = {
      id: number;
      parts: Array<StyleObjectPart>
    }
    
    type StyleObjectPart = {
      css: string;
      media: string;
      sourceMap: ?string
    }
    */


    var stylesInDom = {
      /*
      [id: number]: {
      id: number,
      refs: number,
      parts: Array<(obj?: StyleObjectPart) => void>
      }
      */
    };
    var head = hasDocument && (document.head || document.getElementsByTagName('head')[0]);
    var singletonElement = null;
    var singletonCounter = 0;
    var isProduction = false;

    var noop = function () {};

    var options = null;
    var ssrIdKey = 'data-vue-ssr-id'; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
    // tags it will allow on a page

    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());

    function addStylesClient(parentId, list, _isProduction, _options) {
      isProduction = _isProduction;
      options = _options || {};
      var styles = listToStyles(parentId, list);
      addStylesToDom(styles);
      return function update(newList) {
        var mayRemove = [];

        for (var i = 0; i < styles.length; i++) {
          var item = styles[i];
          var domStyle = stylesInDom[item.id];
          domStyle.refs--;
          mayRemove.push(domStyle);
        }

        if (newList) {
          styles = listToStyles(parentId, newList);
          addStylesToDom(styles);
        } else {
          styles = [];
        }

        for (var i = 0; i < mayRemove.length; i++) {
          var domStyle = mayRemove[i];

          if (domStyle.refs === 0) {
            for (var j = 0; j < domStyle.parts.length; j++) {
              domStyle.parts[j]();
            }

            delete stylesInDom[domStyle.id];
          }
        }
      };
    }

    function addStylesToDom(styles
    /* Array<StyleObject> */
    ) {
      for (var i = 0; i < styles.length; i++) {
        var item = styles[i];
        var domStyle = stylesInDom[item.id];

        if (domStyle) {
          domStyle.refs++;

          for (var j = 0; j < domStyle.parts.length; j++) {
            domStyle.parts[j](item.parts[j]);
          }

          for (; j < item.parts.length; j++) {
            domStyle.parts.push(addStyle(item.parts[j]));
          }

          if (domStyle.parts.length > item.parts.length) {
            domStyle.parts.length = item.parts.length;
          }
        } else {
          var parts = [];

          for (var j = 0; j < item.parts.length; j++) {
            parts.push(addStyle(item.parts[j]));
          }

          stylesInDom[item.id] = {
            id: item.id,
            refs: 1,
            parts: parts
          };
        }
      }
    }

    function createStyleElement() {
      var styleElement = document.createElement('style');
      styleElement.type = 'text/css';
      head.appendChild(styleElement);
      return styleElement;
    }

    function addStyle(obj
    /* StyleObjectPart */
    ) {
      var update, remove;
      var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]');

      if (styleElement) {
        if (isProduction) {
          // has SSR styles and in production mode.
          // simply do nothing.
          return noop;
        } else {
          // has SSR styles but in dev mode.
          // for some reason Chrome can't handle source map in server-rendered
          // style tags - source maps in <style> only works if the style tag is
          // created and inserted dynamically. So we remove the server rendered
          // styles and inject new ones.
          styleElement.parentNode.removeChild(styleElement);
        }
      }

      if (isOldIE) {
        // use singleton mode for IE9.
        var styleIndex = singletonCounter++;
        styleElement = singletonElement || (singletonElement = createStyleElement());
        update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
        remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
      } else {
        // use multi-style-tag mode in all other cases
        styleElement = createStyleElement();
        update = applyToTag.bind(null, styleElement);

        remove = function () {
          styleElement.parentNode.removeChild(styleElement);
        };
      }

      update(obj);
      return function updateStyle(newObj
      /* StyleObjectPart */
      ) {
        if (newObj) {
          if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
            return;
          }

          update(obj = newObj);
        } else {
          remove();
        }
      };
    }

    var replaceText = function () {
      var textStore = [];
      return function (index, replacement) {
        textStore[index] = replacement;
        return textStore.filter(Boolean).join('\n');
      };
    }();

    function applyToSingletonTag(styleElement, index, remove, obj) {
      var css = remove ? '' : obj.css;

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = replaceText(index, css);
      } else {
        var cssNode = document.createTextNode(css);
        var childNodes = styleElement.childNodes;
        if (childNodes[index]) styleElement.removeChild(childNodes[index]);

        if (childNodes.length) {
          styleElement.insertBefore(cssNode, childNodes[index]);
        } else {
          styleElement.appendChild(cssNode);
        }
      }
    }

    function applyToTag(styleElement, obj) {
      var css = obj.css;
      var media = obj.media;
      var sourceMap = obj.sourceMap;

      if (media) {
        styleElement.setAttribute('media', media);
      }

      if (options.ssrId) {
        styleElement.setAttribute(ssrIdKey, obj.id);
      }

      if (sourceMap) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';
      }

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = css;
      } else {
        while (styleElement.firstChild) {
          styleElement.removeChild(styleElement.firstChild);
        }

        styleElement.appendChild(document.createTextNode(css));
      }
    }
    /***/

  },

  /***/
  "8875":
  /***/
  function (module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // addapted from the document.currentScript polyfill by Adam Miller
    // MIT license
    // source: https://github.com/amiller-gh/currentScript-polyfill
    // added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505


    (function (root, factory) {
      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(typeof self !== 'undefined' ? self : this, function () {
      function getCurrentScript() {
        var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript'); // for chrome

        if (!descriptor && 'currentScript' in document && document.currentScript) {
          return document.currentScript;
        } // for other browsers with native support for currentScript


        if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
          return document.currentScript;
        } // IE 8-10 support script readyState
        // IE 11+ & Firefox support stack trace


        try {
          throw new Error();
        } catch (err) {
          // Find the second match for the "at" string to get file src url from stack.
          var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
              ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
              stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
              scriptLocation = stackDetails && stackDetails[1] || false,
              line = stackDetails && stackDetails[2] || false,
              currentLocation = document.location.href.replace(document.location.hash, ''),
              pageSource,
              inlineScriptSourceRegExp,
              inlineScriptSource,
              scripts = document.getElementsByTagName('script'); // Live NodeList collection

          if (scriptLocation === currentLocation) {
            pageSource = document.documentElement.outerHTML;
            inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
            inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
          }

          for (var i = 0; i < scripts.length; i++) {
            // If ready state is interactive, return the script tag
            if (scripts[i].readyState === 'interactive') {
              return scripts[i];
            } // If src matches, return the script tag


            if (scripts[i].src === scriptLocation) {
              return scripts[i];
            } // If inline source matches, return the script tag


            if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
              return scripts[i];
            }
          } // If no match, return null


          return null;
        }
      }

      ;
      return getCurrentScript;
    });
    /***/

  },

  /***/
  "8bbf":
  /***/
  function (module, exports) {
    module.exports = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
    /***/
  },

  /***/
  "9e62":
  /***/
  function (module, exports, __nested_webpack_require_19013__) {
    // Imports
    var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_19013__("24fb");

    exports = ___CSS_LOADER_API_IMPORT___(false); // Module

    exports.push([module.i, ".grid[data-v-24e4d634]{display:grid;align-items:center}", ""]); // Exports

    module.exports = exports;
    /***/
  },

  /***/
  "c489":
  /***/
  function (module, __webpack_exports__, __nested_webpack_require_19398__) {
    "use strict";
    /* harmony import */

    var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VirtualGrid_vue_vue_type_style_index_0_id_24e4d634_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_19398__("c4cd");
    /* harmony import */


    var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VirtualGrid_vue_vue_type_style_index_0_id_24e4d634_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_19398__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VirtualGrid_vue_vue_type_style_index_0_id_24e4d634_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
    /* unused harmony reexport * */

    /***/

  },

  /***/
  "c4cd":
  /***/
  function (module, exports, __nested_webpack_require_21138__) {
    // style-loader: Adds some css to the DOM by adding a <style> tag
    // load the styles
    var content = __nested_webpack_require_21138__("9e62");

    if (content.__esModule) content = content.default;
    if (typeof content === 'string') content = [[module.i, content, '']];
    if (content.locals) module.exports = content.locals; // add the styles to the DOM

    var add = __nested_webpack_require_21138__("499e").default;

    var update = add("d08ad6f0", content, true, {
      "sourceMap": false,
      "shadowMode": false
    });
    /***/
  },

  /***/
  "fb15":
  /***/
  function (module, __webpack_exports__, __nested_webpack_require_21763__) {
    "use strict"; // ESM COMPAT FLAG

    __nested_webpack_require_21763__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
    // This file is imported into lib/wc client bundles.


    if (typeof window !== 'undefined') {
      var currentScript = window.document.currentScript;

      if (true) {
        var getCurrentScript = __nested_webpack_require_21763__("8875");

        currentScript = getCurrentScript(); // for backward compatibility, because previously we directly included the polyfill

        if (!('currentScript' in document)) {
          Object.defineProperty(document, 'currentScript', {
            get: getCurrentScript
          });
        }
      }

      var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);

      if (src) {
        __nested_webpack_require_21763__.p = src[1]; // eslint-disable-line
      }
    } // Indicate to webpack that this file can be concatenated

    /* harmony default export */


    var setPublicPath = null; // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"15c5cc38-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VirtualGrid.vue?vue&type=template&id=24e4d634&scoped=true&

    var render = function () {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        ref: "virtualGrid",
        style: {
          boxSizing: 'border-box',
          height: _vm.layoutData.totalHeight + "px",
          paddingTop: "" + (_vm.renderData !== null && _vm.renderData.firstRenderedRowOffset !== null ? _vm.renderData.firstRenderedRowOffset + 'px' : '0px')
        }
      }, [_c('div', {
        staticClass: "grid",
        style: {
          'grid-template-columns': "repeat(" + _vm.configData.columnCount + ", 1fr)",
          'gap': _vm.configData.gridGap + "px"
        }
      }, _vm._l(_vm.renderData.cellsToRender, function (item) {
        return _c('div', {
          key: item.id,
          style: {
            'height': item.height,
            'grid-column-start': item.columnNumber,
            'grid-column-end': item.columnNumber + item.columnSpan,
            'grid-row-start': _vm.getGridRowStart(item, _vm.renderData)
          }
        }, [_c(item.renderComponent, _vm._g({
          tag: "component",
          attrs: {
            "item": item
          }
        }, _vm.$listeners))], 1);
      }), 0), _c(_vm.loadingBatch && _vm.loader, {
        tag: "component"
      })], 1);
    };

    var staticRenderFns = []; // CONCATENATED MODULE: ./src/VirtualGrid.vue?vue&type=template&id=24e4d634&scoped=true&
    // CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */

    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
      var t = {};

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }

    function __decorate(decorators, target, key, desc) {
      var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    }

    function __metadata(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    function __createBinding(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    }

    function __exportStar(m, exports) {
      for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
          r,
          ar = [],
          e;

      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }

      return ar;
    }

    function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

      return ar;
    }

    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

      return r;
    }

    ;

    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i;

      function verb(n) {
        if (g[n]) i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }

      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }

      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }

      function fulfill(value) {
        resume("next", value);
      }

      function reject(value) {
        resume("throw", value);
      }

      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }

    function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function () {
        return this;
      }, i;

      function verb(n, f) {
        i[n] = o[n] ? function (v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: n === "return"
          } : f ? f(v) : v;
        } : f;
      }
    }

    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator],
          i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i);

      function verb(n) {
        i[n] = o[n] && function (v) {
          return new Promise(function (resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }

      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
          resolve({
            value: v,
            done: d
          });
        }, reject);
      }
    }

    function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
          value: raw
        });
      } else {
        cooked.raw = raw;
      }

      return cooked;
    }

    ;

    function __importStar(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result.default = mod;
      return result;
    }

    function __importDefault(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      privateMap.set(receiver, value);
      return value;
    } // EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}


    var external_commonjs_vue_commonjs2_vue_root_Vue_ = __nested_webpack_require_21763__("8bbf");

    var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__nested_webpack_require_21763__.n(external_commonjs_vue_commonjs2_vue_root_Vue_); // CONCATENATED MODULE: ./node_modules/vue-class-component/dist/vue-class-component.esm.js

    /**
      * vue-class-component v7.2.6
      * (c) 2015-present Evan You
      * @license MIT
      */


    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    } // The rational behind the verbose Reflect-feature check below is the fact that there are polyfills
    // which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.
    // Without this check consumers will encounter hard to track down runtime errors.


    function reflectionIsSupported() {
      return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;
    }

    function copyReflectionMetadata(to, from) {
      forwardMetadata(to, from);
      Object.getOwnPropertyNames(from.prototype).forEach(function (key) {
        forwardMetadata(to.prototype, from.prototype, key);
      });
      Object.getOwnPropertyNames(from).forEach(function (key) {
        forwardMetadata(to, from, key);
      });
    }

    function forwardMetadata(to, from, propertyKey) {
      var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);
      metaKeys.forEach(function (metaKey) {
        var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);

        if (propertyKey) {
          Reflect.defineMetadata(metaKey, metadata, to, propertyKey);
        } else {
          Reflect.defineMetadata(metaKey, metadata, to);
        }
      });
    }

    var fakeArray = {
      __proto__: []
    };
    var hasProto = fakeArray instanceof Array;

    function createDecorator(factory) {
      return function (target, key, index) {
        var Ctor = typeof target === 'function' ? target : target.constructor;

        if (!Ctor.__decorators__) {
          Ctor.__decorators__ = [];
        }

        if (typeof index !== 'number') {
          index = undefined;
        }

        Ctor.__decorators__.push(function (options) {
          return factory(options, key, index);
        });
      };
    }

    function mixins() {
      for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {
        Ctors[_key] = arguments[_key];
      }

      return external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
        mixins: Ctors
      });
    }

    function isPrimitive(value) {
      var type = _typeof(value);

      return value == null || type !== 'object' && type !== 'function';
    }

    function warn(message) {
      if (typeof console !== 'undefined') {
        console.warn('[vue-class-component] ' + message);
      }
    }

    function collectDataFromConstructor(vm, Component) {
      // override _init to prevent to init as Vue instance
      var originalInit = Component.prototype._init;

      Component.prototype._init = function () {
        var _this = this; // proxy to actual vm


        var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)

        if (vm.$options.props) {
          for (var key in vm.$options.props) {
            if (!vm.hasOwnProperty(key)) {
              keys.push(key);
            }
          }
        }

        keys.forEach(function (key) {
          Object.defineProperty(_this, key, {
            get: function get() {
              return vm[key];
            },
            set: function set(value) {
              vm[key] = value;
            },
            configurable: true
          });
        });
      }; // should be acquired class property values


      var data = new Component(); // restore original _init to avoid memory leak (#209)

      Component.prototype._init = originalInit; // create plain data object

      var plainData = {};
      Object.keys(data).forEach(function (key) {
        if (data[key] !== undefined) {
          plainData[key] = data[key];
        }
      });

      if (false) {}

      return plainData;
    }

    var $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6
    ];

    function componentFactory(Component) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options.name = options.name || Component._componentTag || Component.name; // prototype props.

      var proto = Component.prototype;
      Object.getOwnPropertyNames(proto).forEach(function (key) {
        if (key === 'constructor') {
          return;
        } // hooks


        if ($internalHooks.indexOf(key) > -1) {
          options[key] = proto[key];
          return;
        }

        var descriptor = Object.getOwnPropertyDescriptor(proto, key);

        if (descriptor.value !== void 0) {
          // methods
          if (typeof descriptor.value === 'function') {
            (options.methods || (options.methods = {}))[key] = descriptor.value;
          } else {
            // typescript decorated data
            (options.mixins || (options.mixins = [])).push({
              data: function data() {
                return _defineProperty({}, key, descriptor.value);
              }
            });
          }
        } else if (descriptor.get || descriptor.set) {
          // computed properties
          (options.computed || (options.computed = {}))[key] = {
            get: descriptor.get,
            set: descriptor.set
          };
        }
      });
      (options.mixins || (options.mixins = [])).push({
        data: function data() {
          return collectDataFromConstructor(this, Component);
        }
      }); // decorate options

      var decorators = Component.__decorators__;

      if (decorators) {
        decorators.forEach(function (fn) {
          return fn(options);
        });
        delete Component.__decorators__;
      } // find super


      var superProto = Object.getPrototypeOf(Component.prototype);
      var Super = superProto instanceof external_commonjs_vue_commonjs2_vue_root_Vue_default.a ? superProto.constructor : external_commonjs_vue_commonjs2_vue_root_Vue_default.a;
      var Extended = Super.extend(options);
      forwardStaticMembers(Extended, Component, Super);

      if (reflectionIsSupported()) {
        copyReflectionMetadata(Extended, Component);
      }

      return Extended;
    }

    var reservedPropertyNames = [// Unique id
    'cid', // Super Vue constructor
    'super', // Component options that will be used by the component
    'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets
    'component', 'directive', 'filter'];
    var shouldIgnore = {
      prototype: true,
      arguments: true,
      callee: true,
      caller: true
    };

    function forwardStaticMembers(Extended, Original, Super) {
      // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable
      Object.getOwnPropertyNames(Original).forEach(function (key) {
        // Skip the properties that should not be overwritten
        if (shouldIgnore[key]) {
          return;
        } // Some browsers does not allow reconfigure built-in properties


        var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);

        if (extendedDescriptor && !extendedDescriptor.configurable) {
          return;
        }

        var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),
        // the sub class properties may be inherited properties from the super class in TypeScript.
        // We need to exclude such properties to prevent to overwrite
        // the component options object which stored on the extended constructor (See #192).
        // If the value is a referenced value (object or function),
        // we can check equality of them and exclude it if they have the same reference.
        // If it is a primitive value, it will be forwarded for safety.

        if (!hasProto) {
          // Only `cid` is explicitly exluded from property forwarding
          // because we cannot detect whether it is a inherited property or not
          // on the no `__proto__` environment even though the property is reserved.
          if (key === 'cid') {
            return;
          }

          var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);

          if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {
            return;
          }
        } // Warn if the users manually declare reserved properties


        if (false) {}

        Object.defineProperty(Extended, key, descriptor);
      });
    }

    function vue_class_component_esm_Component(options) {
      if (typeof options === 'function') {
        return componentFactory(options);
      }

      return function (Component) {
        return componentFactory(Component, options);
      };
    }

    vue_class_component_esm_Component.registerHooks = function registerHooks(keys) {
      $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));
    };
    /* harmony default export */


    var vue_class_component_esm = vue_class_component_esm_Component; // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Emit.js

    var Emit_spreadArrays = undefined && undefined.__spreadArrays || function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

      return r;
    }; // Code copied from Vue/src/shared/util.js


    var hyphenateRE = /\B([A-Z])/g;

    var hyphenate = function (str) {
      return str.replace(hyphenateRE, '-$1').toLowerCase();
    };
    /**
     * decorator of an event-emitter function
     * @param  event The name of the event
     * @return MethodDecorator
     */


    function Emit(event) {
      return function (_target, propertyKey, descriptor) {
        var key = hyphenate(propertyKey);
        var original = descriptor.value;

        descriptor.value = function emitter() {
          var _this = this;

          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          var emit = function (returnValue) {
            var emitName = event || key;

            if (returnValue === undefined) {
              if (args.length === 0) {
                _this.$emit(emitName);
              } else if (args.length === 1) {
                _this.$emit(emitName, args[0]);
              } else {
                _this.$emit.apply(_this, Emit_spreadArrays([emitName], args));
              }
            } else {
              args.unshift(returnValue);

              _this.$emit.apply(_this, Emit_spreadArrays([emitName], args));
            }
          };

          var returnValue = original.apply(this, args);

          if (isPromise(returnValue)) {
            returnValue.then(emit);
          } else {
            emit(returnValue);
          }

          return returnValue;
        };
      };
    }

    function isPromise(obj) {
      return obj instanceof Promise || obj && typeof obj.then === 'function';
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Inject.js

    /**
     * decorator of an inject
     * @param from key
     * @return PropertyDecorator
     */


    function Inject(options) {
      return createDecorator(function (componentOptions, key) {
        if (typeof componentOptions.inject === 'undefined') {
          componentOptions.inject = {};
        }

        if (!Array.isArray(componentOptions.inject)) {
          componentOptions.inject[key] = options || key;
        }
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/helpers/provideInject.js


    function needToProduceProvide(original) {
      return typeof original !== 'function' || !original.managed && !original.managedReactive;
    }

    function produceProvide(original) {
      var provide = function () {
        var _this = this;

        var rv = typeof original === 'function' ? original.call(this) : original;
        rv = Object.create(rv || null); // set reactive services (propagates previous services if necessary)

        rv[reactiveInjectKey] = Object.create(this[reactiveInjectKey] || {});

        for (var i in provide.managed) {
          rv[provide.managed[i]] = this[i];
        }

        var _loop_1 = function (i) {
          rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`

          Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {
            enumerable: true,
            configurable: true,
            get: function () {
              return _this[i];
            }
          });
        };

        var this_1 = this;

        for (var i in provide.managedReactive) {
          _loop_1(i);
        }

        return rv;
      };

      provide.managed = {};
      provide.managedReactive = {};
      return provide;
    }
    /** Used for keying reactive provide/inject properties */


    var reactiveInjectKey = '__reactiveInject__';

    function inheritInjected(componentOptions) {
      // inject parent reactive services (if any)
      if (!Array.isArray(componentOptions.inject)) {
        componentOptions.inject = componentOptions.inject || {};
        componentOptions.inject[reactiveInjectKey] = {
          from: reactiveInjectKey,
          default: {}
        };
      }
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/InjectReactive.js

    /**
     * decorator of a reactive inject
     * @param from key
     * @return PropertyDecorator
     */


    function InjectReactive(options) {
      return createDecorator(function (componentOptions, key) {
        if (typeof componentOptions.inject === 'undefined') {
          componentOptions.inject = {};
        }

        if (!Array.isArray(componentOptions.inject)) {
          var fromKey_1 = !!options ? options.from || options : key;
          var defaultVal_1 = !!options && options.default || undefined;
          if (!componentOptions.computed) componentOptions.computed = {};

          componentOptions.computed[key] = function () {
            var obj = this[reactiveInjectKey];
            return obj ? obj[fromKey_1] : defaultVal_1;
          };

          componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;
        }
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/helpers/metadata.js

    /** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */


    var reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';

    function applyMetadata(options, target, key) {
      if (reflectMetadataIsSupported) {
        if (!Array.isArray(options) && typeof options !== 'function' && !options.hasOwnProperty('type') && typeof options.type === 'undefined') {
          var type = Reflect.getMetadata('design:type', target, key);

          if (type !== Object) {
            options.type = type;
          }
        }
      }
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Model.js

    /**
     * decorator of model
     * @param  event event name
     * @param options options
     * @return PropertyDecorator
     */


    function Model(event, options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[k] = options;
          componentOptions.model = {
            prop: k,
            event: event || k
          };
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/ModelSync.js

    /**
     * decorator of synced model and prop
     * @param propName the name to interface with from outside, must be different from decorated property
     * @param  event event name
     * @param options options
     * @return PropertyDecorator
     */


    function ModelSync(propName, event, options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[propName] = options;
          componentOptions.model = {
            prop: propName,
            event: event || k
          };
          (componentOptions.computed || (componentOptions.computed = {}))[k] = {
            get: function () {
              return this[propName];
            },
            set: function (value) {
              // @ts-ignore
              this.$emit(event, value);
            }
          };
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Prop.js

    /**
     * decorator of a prop
     * @param  options the options for the prop
     * @return PropertyDecorator | void
     */


    function Prop(options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[k] = options;
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/PropSync.js

    /**
     * decorator of a synced prop
     * @param propName the name to interface with from outside, must be different from decorated property
     * @param options the options for the synced prop
     * @return PropertyDecorator | void
     */


    function PropSync(propName, options) {
      if (options === void 0) {
        options = {};
      }

      return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
          ;
          (componentOptions.props || (componentOptions.props = {}))[propName] = options;
          (componentOptions.computed || (componentOptions.computed = {}))[k] = {
            get: function () {
              return this[propName];
            },
            set: function (value) {
              this.$emit("update:" + propName, value);
            }
          };
        })(target, key);
      };
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Provide.js

    /**
     * decorator of a provide
     * @param key key
     * @return PropertyDecorator | void
     */


    function Provide(key) {
      return createDecorator(function (componentOptions, k) {
        var provide = componentOptions.provide;
        inheritInjected(componentOptions);

        if (needToProduceProvide(provide)) {
          provide = componentOptions.provide = produceProvide(provide);
        }

        provide.managed[k] = key || k;
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/ProvideReactive.js

    /**
     * decorator of a reactive provide
     * @param key key
     * @return PropertyDecorator | void
     */


    function ProvideReactive(key) {
      return createDecorator(function (componentOptions, k) {
        var provide = componentOptions.provide;
        inheritInjected(componentOptions);

        if (needToProduceProvide(provide)) {
          provide = componentOptions.provide = produceProvide(provide);
        }

        provide.managedReactive[k] = key || k;
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Ref.js

    /**
     * decorator of a ref prop
     * @param refKey the ref key defined in template
     */


    function Ref(refKey) {
      return createDecorator(function (options, key) {
        options.computed = options.computed || {};
        options.computed[key] = {
          cache: false,
          get: function () {
            return this.$refs[refKey || key];
          }
        };
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/VModel.js

    /**
     * decorator for capturings v-model binding to component
     * @param options the options for the prop
     */


    function VModel(options) {
      if (options === void 0) {
        options = {};
      }

      var valueKey = 'value';
      return createDecorator(function (componentOptions, key) {
        ;
        (componentOptions.props || (componentOptions.props = {}))[valueKey] = options;
        (componentOptions.computed || (componentOptions.computed = {}))[key] = {
          get: function () {
            return this[valueKey];
          },
          set: function (value) {
            this.$emit('input', value);
          }
        };
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Watch.js

    /**
     * decorator of a watch function
     * @param  path the path or the expression to observe
     * @param  WatchOption
     * @return MethodDecorator
     */


    function Watch(path, options) {
      if (options === void 0) {
        options = {};
      }

      var _a = options.deep,
          deep = _a === void 0 ? false : _a,
          _b = options.immediate,
          immediate = _b === void 0 ? false : _b;
      return createDecorator(function (componentOptions, handler) {
        if (typeof componentOptions.watch !== 'object') {
          componentOptions.watch = Object.create(null);
        }

        var watch = componentOptions.watch;

        if (typeof watch[path] === 'object' && !Array.isArray(watch[path])) {
          watch[path] = [watch[path]];
        } else if (typeof watch[path] === 'undefined') {
          watch[path] = [];
        }

        watch[path].push({
          handler: handler,
          deep: deep,
          immediate: immediate
        });
      });
    } // CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/index.js

    /** vue-property-decorator verson 9.1.2 MIT LICENSE copyright 2020 kaorun343 */
    /// <reference types='reflect-metadata'/>
    // CONCATENATED MODULE: ./src/utils.ts


    const getGridGapDefault = (elementWidth, windowHeight) => {
      if (elementWidth > 720 && windowHeight > 480) {
        return 10;
      } else {
        return 5;
      }
    };

    const getColumnCountDefault = elementWidth => {
      return Math.floor(elementWidth / 250);
    };

    const getWindowMarginDefault = windowHeight => {
      return Math.round(windowHeight * 1.5);
    };

    const getItemRatioHeightDefault = (height, width, columnWidth) => {
      const imageRatio = height / width;
      return Math.round(columnWidth * imageRatio);
    };

    const debugLog = (condition, ...args) => {
      if (condition) {
        console.debug(...args);
      }
    }; // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/ts-loader??ref--13-2!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VirtualGrid.vue?vue&type=script&lang=ts&


    var VirtualGridvue_type_script_lang_ts_a, VirtualGridvue_type_script_lang_ts_b;
    let VirtualGridvue_type_script_lang_ts_VirtualGrid = class VirtualGrid extends external_commonjs_vue_commonjs2_vue_root_Vue_default.a {
      constructor() {
        super(...arguments);
        this.updateLock = false;
        this.bottomReached = false;
        this.ref = null;
        this.containerData = {
          windowSize: {
            height: 0,
            width: 0
          },
          windowScroll: {
            x: 0,
            y: 0
          },
          elementWindowOffset: 0,
          elementSize: {
            height: 0,
            width: 0
          }
        };
      }

      get loadingBatch() {
        return this.loader && this.updateLock;
      }

      get configData() {
        return this.computeConfigData(this.containerData, this.items);
      }

      get layoutData() {
        return this.computeLayoutData(this.configData);
      }

      get renderData() {
        return this.computeRenderData(this.configData, this.containerData, this.layoutData);
      }

      mounted() {
        this.ref = this.$refs.virtualGrid;
        this.initiliazeGrid();
        window.addEventListener('resize', this.resize);
        window.addEventListener('scroll', this.scroll);
      }

      beforeDestroy() {
        window.removeEventListener('resize', this.resize);
        window.removeEventListener('scroll', this.scroll);
      }

      resize() {
        this.loadMoreData();
      }

      scroll() {
        this.loadMoreData();
      }

      initiliazeGrid() {
        this.computeContainerData();
        this.$nextTick(async () => {
          this.loadMoreData();
        });
      }

      loadMoreData() {
        this.loadMoreDataAsync().catch(error => {
          if (error) {
            console.error('Fail to load next data batch', error);
          }
        }).then();
      }

      async loadMoreDataAsync() {
        this.computeContainerData();
        const windowTop = this.containerData.windowScroll.y;
        const windowBottom = windowTop + this.containerData.windowSize.height;
        const bottomTrigger = Math.max(0, this.containerData.elementWindowOffset + this.containerData.elementSize.height - this.updateTriggerMargin);

        if (!this.bottomReached && windowBottom >= bottomTrigger && !this.updateLock) {
          this.updateLock = true;
          debugLog(this.debug, 'Loading next batch');
          const isLastBatch = await this.updateFunction();

          if (isLastBatch) {
            debugLog(this.debug, 'Bottom reached');
            this.bottomReached = true;
          }

          this.updateLock = false;
          await this.loadMoreDataAsync();
        }

        return;
      }

      computeContainerData() {
        if (this.ref === null) {
          return;
        }

        const windowSize = this.getWindowSize();
        const windowScroll = this.getWindowScroll();
        const elementWindowOffset = this.getElementOffset(this.ref);
        const elementSize = this.getElementSize(this.ref);
        this.containerData = {
          windowSize,
          windowScroll,
          elementWindowOffset,
          elementSize
        };
      }

      computeConfigData(containerData, items) {
        if (containerData === null || items === null) {
          return {
            windowMargin: 0,
            gridGap: 0,
            columnCount: 1,
            entries: []
          };
        }

        const elementWidth = containerData.elementSize ? containerData.elementSize.width : null;
        const windowMargin = this.getWindowMargin(containerData.windowSize.height);
        const gridGap = this.getGridGap(elementWidth, containerData.windowSize.height);
        const columnCount = this.getColumnCount(elementWidth);
        const columnWidth = this.getColumnWidth(columnCount, gridGap, elementWidth);
        const entries = items.map(item => {
          if (!item.width) {
            return item;
          }

          const imageWidth = columnWidth * item.columnSpan + gridGap * (item.columnSpan - 1);
          return { ...item,
            height: this.getItemRatioHeight(item.height, item.width, imageWidth),
            width: imageWidth
          };
        });
        return {
          windowMargin,
          gridGap,
          columnCount,
          entries
        };
      }

      computeLayoutData(configData) {
        if (configData === null) {
          return {
            cells: [],
            totalHeight: 0
          };
        }

        let currentRowNumber = 1;
        let prevRowsTotalHeight = 0;
        let currentRowMaxHeight = 0;
        let columnShift = 0;
        const cells = configData.entries.map((entry, index) => {
          const {
            columnCount,
            gridGap
          } = configData;
          let columnSpanRecompute = entry.columnSpan;
          let heightRecompute = entry.height;

          if (columnSpanRecompute < 1) {
            columnSpanRecompute = columnCount;
          }

          const distanceToRowStart = (index + columnShift) % columnCount;

          if (entry.newRow && distanceToRowStart !== 0) {
            columnShift += columnCount - distanceToRowStart;
          }

          const shiftedIndex = index + columnShift;
          const columnNumber = shiftedIndex % columnCount + 1;
          const rowNumber = Math.floor(shiftedIndex / columnCount) + 1;

          if (columnNumber + columnSpanRecompute > columnCount + 1) {
            const overlapNumber = columnNumber + columnSpanRecompute - columnCount - 1;
            const overlapRatio = overlapNumber / columnSpanRecompute;
            heightRecompute = heightRecompute * (1 - overlapRatio);
            columnSpanRecompute -= overlapNumber;
          }

          if (columnSpanRecompute > 1) {
            columnShift += columnSpanRecompute - 1;
          }

          if (rowNumber !== currentRowNumber) {
            currentRowNumber = rowNumber;
            prevRowsTotalHeight += currentRowMaxHeight + gridGap;
            currentRowMaxHeight = 0;
          }

          const offset = prevRowsTotalHeight;
          const height = Math.round(heightRecompute);
          currentRowMaxHeight = Math.max(currentRowMaxHeight, height);
          return { ...entry,
            columnNumber,
            rowNumber,
            offset,
            height,
            columnSpan: columnSpanRecompute
          };
        });
        const totalHeight = prevRowsTotalHeight + currentRowMaxHeight;
        return {
          cells,
          totalHeight
        };
      }

      computeRenderData(configData, containerData, layoutData) {
        if (layoutData === null || configData === null) {
          return {
            cellsToRender: [],
            firstRenderedRowNumber: 0,
            firstRenderedRowOffset: 0
          };
        }

        const cellsToRender = [];
        let firstRenderedRowNumber = null;
        let firstRenderedRowOffset = null;

        if (containerData.elementWindowOffset !== null) {
          const elementWindowOffset = containerData.elementWindowOffset;

          for (const cell of layoutData.cells) {
            const cellTop = elementWindowOffset + cell.offset;
            const cellBottom = cellTop + cell.height;
            const windowTop = containerData.windowScroll.y;
            const windowBottom = windowTop + containerData.windowSize.height;
            const renderTop = windowTop - configData.windowMargin;
            const renderBottom = windowBottom + configData.windowMargin;

            if (cellTop > renderBottom) {
              continue;
            }

            if (cellBottom < renderTop) {
              continue;
            }

            if (firstRenderedRowNumber === null) {
              firstRenderedRowNumber = cell.rowNumber;
            }

            if (cell.rowNumber === firstRenderedRowNumber) {
              firstRenderedRowOffset = firstRenderedRowOffset ? Math.min(firstRenderedRowOffset, cell.offset) : cell.offset;
            }

            cellsToRender.push(cell);
          }
        }

        return {
          cellsToRender,
          firstRenderedRowNumber,
          firstRenderedRowOffset
        };
      }

      getColumnWidth(columnCount, gridGap, elementWidth) {
        if (columnCount === null || gridGap === null || elementWidth === null) {
          return null;
        }

        const totalGapSpace = (columnCount - 1) * gridGap;
        const columnWidth = Math.round((elementWidth - totalGapSpace) / columnCount);
        return columnWidth;
      }

      getGridRowStart(cell, renderData) {
        if (renderData === null) {
          return undefined;
        }

        const offset = renderData.firstRenderedRowNumber !== null ? renderData.firstRenderedRowNumber - 1 : 0;
        const gridRowStart = cell.rowNumber - offset;
        return "".concat(gridRowStart);
      }

      resetGrid() {
        this.bottomReached = false;
        this.loadMoreData();
      }

      isSameElementSize(a, b) {
        return a.width === b.width && a.height === b.height;
      }

      getWindowSize() {
        return {
          width: window.innerWidth,
          height: window.innerHeight
        };
      }

      getElementSize(element) {
        const rect = element.getBoundingClientRect();
        return {
          width: rect.width,
          height: rect.height
        };
      }

      isSameElementScroll(a, b) {
        return a.x === b.x && a.y === b.y;
      }

      getWindowScroll() {
        return {
          x: window.scrollX,
          y: window.scrollY
        };
      }

      getElementOffset(element) {
        return window.scrollY + element.getBoundingClientRect().top;
      }

    };

    __decorate([Prop({
      required: true
    }), __metadata("design:type", Array)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "items", void 0);

    __decorate([Prop({
      default: () => () => true
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "updateFunction", void 0);

    __decorate([Prop({
      default: () => getGridGapDefault
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getGridGap", void 0);

    __decorate([Prop({
      default: () => getColumnCountDefault
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getColumnCount", void 0);

    __decorate([Prop({
      default: () => getWindowMarginDefault
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getWindowMargin", void 0);

    __decorate([Prop({
      default: () => getItemRatioHeightDefault
    }), __metadata("design:type", Function)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "getItemRatioHeight", void 0);

    __decorate([Prop({
      default: 500
    }), __metadata("design:type", Number)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "updateTriggerMargin", void 0);

    __decorate([Prop({
      default: null
    }), __metadata("design:type", typeof (VirtualGridvue_type_script_lang_ts_a = typeof external_commonjs_vue_commonjs2_vue_root_Vue_default.a !== "undefined" && external_commonjs_vue_commonjs2_vue_root_Vue_default.a.Component) === "function" ? VirtualGridvue_type_script_lang_ts_a : Object)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "loader", void 0);

    __decorate([Prop({
      default: false
    }), __metadata("design:type", Boolean)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "debug", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", Boolean)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "updateLock", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", Boolean)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "bottomReached", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", typeof (VirtualGridvue_type_script_lang_ts_b = typeof Element !== "undefined" && Element) === "function" ? VirtualGridvue_type_script_lang_ts_b : Object)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "ref", void 0);

    __decorate([ProvideReactive(), __metadata("design:type", Object)], VirtualGridvue_type_script_lang_ts_VirtualGrid.prototype, "containerData", void 0);

    VirtualGridvue_type_script_lang_ts_VirtualGrid = __decorate([vue_class_component_esm], VirtualGridvue_type_script_lang_ts_VirtualGrid);
    /* harmony default export */

    var VirtualGridvue_type_script_lang_ts_ = VirtualGridvue_type_script_lang_ts_VirtualGrid; // CONCATENATED MODULE: ./src/VirtualGrid.vue?vue&type=script&lang=ts&

    /* harmony default export */

    var src_VirtualGridvue_type_script_lang_ts_ = VirtualGridvue_type_script_lang_ts_; // EXTERNAL MODULE: ./src/VirtualGrid.vue?vue&type=style&index=0&id=24e4d634&scoped=true&lang=css&

    var VirtualGridvue_type_style_index_0_id_24e4d634_scoped_true_lang_css_ = __nested_webpack_require_21763__("c489"); // CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js

    /* globals __VUE_SSR_CONTEXT__ */
    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
    // This module is a runtime utility for cleaner component module output and will
    // be included in the final webpack user bundle.


    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier,
    /* server only */
    shadowMode
    /* vue-cli only */
    ) {
      // Vue.extend constructor export interop
      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports; // render functions

      if (render) {
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        options._compiled = true;
      } // functional template


      if (functionalTemplate) {
        options.functional = true;
      } // scopedId


      if (scopeId) {
        options._scopeId = 'data-v-' + scopeId;
      }

      var hook;

      if (moduleIdentifier) {
        // server build
        hook = function (context) {
          // 2.3 injection
          context = context || // cached call
          this.$vnode && this.$vnode.ssrContext || // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true

          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          } // inject component styles


          if (injectStyles) {
            injectStyles.call(this, context);
          } // register component module identifier for async chunk inferrence


          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        }; // used by ssr in case component is cached and beforeCreate
        // never gets called


        options._ssrRegister = hook;
      } else if (injectStyles) {
        hook = shadowMode ? function () {
          injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
        } : injectStyles;
      }

      if (hook) {
        if (options.functional) {
          // for template-only hot-reload because in that case the render fn doesn't
          // go through the normalizer
          options._injectStyles = hook; // register for functional component in vue file

          var originalRender = options.render;

          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }

      return {
        exports: scriptExports,
        options: options
      };
    } // CONCATENATED MODULE: ./src/VirtualGrid.vue

    /* normalize component */


    var component = normalizeComponent(src_VirtualGridvue_type_script_lang_ts_, render, staticRenderFns, false, null, "24e4d634", null);
    /* harmony default export */

    var src_VirtualGrid = component.exports; // CONCATENATED MODULE: ./src/main.ts

    /* harmony default export */

    var main = src_VirtualGrid; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

    /* harmony default export */

    var entry_lib = __webpack_exports__["default"] = main;
    /***/
  }
  /******/

});

/***/ })

}]);
//# sourceMappingURL=photos-vendors-node_modules_vue-virtual-grid_dist_virtual-grid_common_js.js.map?v=23e634838c2fa871f9e6