{"version":3,"file":"photos-src_mixins_FetchCollectionContentMixin_js.js?v=51427cd203cde0eb0e8b","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///photos/src/mixins/FetchCollectionContentMixin.js","webpack:///photos/src/services/collectionFetcher.js"],"sourcesContent":["/**\n * @copyright Copyright (c) 2022 Louis Chemineau <louis@chmn.me>\n *\n * @author Louis Chemineau <louis@chmn.me>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nimport { mapActions } from 'vuex';\nimport { showError } from '@nextcloud/dialogs';\nimport AbortControllerMixin from './AbortControllerMixin.js';\nimport { fetchCollection, fetchCollectionFiles } from '../services/collectionFetcher.js';\nimport logger from '../services/logger.js';\nimport SemaphoreWithPriority from '../utils/semaphoreWithPriority.js';\nexport default {\n  name: 'FetchCollectionContentMixin',\n  data() {\n    return {\n      fetchSemaphore: new SemaphoreWithPriority(1),\n      loadingCollection: false,\n      loadingCollectionFiles: false,\n      errorFetchingCollection: null,\n      errorFetchingCollectionFiles: null\n    };\n  },\n  mixins: [AbortControllerMixin],\n  methods: {\n    ...mapActions(['appendFiles', 'addCollections', 'setCollectionFiles']),\n    /**\n     * @param {string} collectionFileName\n     * @param {string[]} [extraProps] - Extra properties to add to the DAV request.\n     * @param {import('webdav').WebDAVClient} [client] - The DAV client to use.\n     * @return {Promise<import('../services/collectionFetcher.js').Collection|null>}\n     */\n    async fetchCollection(collectionFileName, extraProps, client) {\n      if (this.loadingCollection) {\n        return null;\n      }\n      try {\n        this.loadingCollection = true;\n        this.errorFetchingCollection = null;\n        const collection = await fetchCollection(collectionFileName, {\n          signal: this.abortController.signal\n        }, extraProps, client);\n        this.addCollections({\n          collections: [collection]\n        });\n        return collection;\n      } catch (error) {\n        if (error.response?.status === 404) {\n          this.errorFetchingCollection = 404;\n          return null;\n        }\n        this.errorFetchingCollection = error;\n        logger.error('[PublicCollectionContent] Error fetching collection', {\n          error\n        });\n        showError(this.t('photos', 'Failed to fetch collection.'));\n      } finally {\n        this.loadingCollection = false;\n      }\n      return null;\n    },\n    /**\n     * @param {string} collectionFileName\n     * @param {string[]} [extraProps] - Extra properties to add to the DAV request.\n     * @param {import('webdav').WebDAVClient} [client] - The DAV client to use.\n     * @param {((value: import('../services/collectionFetcher.js').CollectionFile, index: number, array: import('../services/collectionFetcher.js').CollectionFile[]) => any)[]} [mappers] - Callback that can transform files before they are appended.\n     * @return {Promise<import('../services/collectionFetcher.js').CollectionFile[]>}\n     */\n    async fetchCollectionFiles(collectionFileName, extraProps, client) {\n      let mappers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      if (this.loadingCollectionFiles) {\n        return [];\n      }\n      const fetchSemaphoreSymbol = await this.fetchSemaphore.acquire();\n      try {\n        this.errorFetchingCollectionFiles = null;\n        this.loadingCollectionFiles = true;\n        let fetchedFiles = await fetchCollectionFiles(collectionFileName, {\n          signal: this.abortController.signal\n        }, extraProps, client);\n        const fileIds = fetchedFiles.map(file => file.fileid.toString());\n        mappers.forEach(mapper => fetchedFiles = fetchedFiles.map(mapper));\n        this.appendFiles(fetchedFiles);\n        if (fetchedFiles.length > 0) {\n          await this.$store.commit('setCollectionFiles', {\n            collectionFileName,\n            fileIds\n          });\n        }\n        return fetchedFiles;\n      } catch (error) {\n        if (error.response?.status === 404) {\n          this.errorFetchingCollectionFiles = 404;\n          return [];\n        }\n        this.errorFetchingCollectionFiles = error;\n        showError(this.t('photos', 'Failed to fetch collections list.'));\n        logger.error('[PublicCollectionContent] Error fetching collection files', {\n          error\n        });\n      } finally {\n        this.loadingCollectionFiles = false;\n        this.fetchSemaphore.release(fetchSemaphoreSymbol);\n      }\n      return [];\n    }\n  }\n};","/**\n * @copyright Copyright (c) 2022 Louis Chemineau <louis@chmn.me>\n *\n * @author Louis Chemineau <louis@chmn.me>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nimport moment from '@nextcloud/moment';\nimport { translate as t } from '@nextcloud/l10n';\nimport defaultClient from './DavClient.js';\nimport logger from './logger.js';\nimport { genFileInfo } from '../utils/fileUtils.js';\n\n/**\n * @typedef {object} Collection\n * @property {string} basename - The name of the collection (ex: \"Athens\").\n * @property {string} filename - The filename of the collection (ex: \"/photos/admin/places/Athens\").\n * @property {string} source - The full source of the collection (ex: \"https://nextcloud_server1.test/remote.php/dav//photos/admin/places/Athens\").\n * @property {number} nbItems - The number of item in the collection.\n * @property {number} lastPhoto - The file id for the cover of the collection.\n */\n\n/**\n * @typedef {object} CollectionFile\n * @property {string} fileid - The id of the file.\n * @property {string} basename - The name of the file (ex: \"790-IMG_20180906_085724.jpg\").\n * @property {string} filename - The file name of the file (ex: \"/photos/admin/places/Athens/790-IMG_20180906_085724.jpg\").\n * @property {string} source - The full source of the collection (ex: \"https://nextcloud_server1.test/remote.php/dav//photos/admin/places/Athens/790-IMG_20180906_085724.jpg\").\n * @property {object} metadataPhotosSize - The metadata of the file.\n * @property {number} metadataPhotosSize.width - The width of the file.\n * @property {number} metadataPhotosSize.height - The height of the file.\n */\n\n/** @typedef {Object<string, Collection>} IndexedCollections */\n/** @typedef {Object<string, CollectionFile>} IndexedCollectionFiles */\n\n/**\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @return {string}\n */\nfunction getCollectionDavRequest() {\n  let extraProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return `<?xml version=\"1.0\"?>\n\t\t\t<d:propfind xmlns:d=\"DAV:\"\n\t\t\t\txmlns:oc=\"http://owncloud.org/ns\"\n\t\t\t\txmlns:nc=\"http://nextcloud.org/ns\"\n\t\t\t\txmlns:ocs=\"http://open-collaboration-services.org/ns\">\n\t\t\t\t<d:prop>\n\t\t\t\t\t<nc:last-photo />\n\t\t\t\t\t<nc:nbItems />\n\t\t\t\t\t${extraProps.join('')}\n\t\t\t\t</d:prop>\n\t\t\t</d:propfind>`;\n}\n\n/**\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @return {string}\n */\nfunction getCollectionFilesDavRequest() {\n  let extraProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return `<?xml version=\"1.0\"?>\n\t\t\t<d:propfind xmlns:d=\"DAV:\"\n\t\t\t\txmlns:oc=\"http://owncloud.org/ns\"\n\t\t\t\txmlns:nc=\"http://nextcloud.org/ns\"\n\t\t\t\txmlns:ocs=\"http://open-collaboration-services.org/ns\">\n\t\t\t\t<d:prop>\n\t\t\t\t\t<d:getcontentlength />\n\t\t\t\t\t<d:getcontenttype />\n\t\t\t\t\t<d:getetag />\n\t\t\t\t\t<d:getlastmodified />\n\t\t\t\t\t<d:resourcetype />\n\t\t\t\t\t<nc:metadata-photos-size />\n\t\t\t\t\t<nc:metadata-photos-original_date_time />\n\t\t\t\t\t<nc:metadata-files-live-photo />\n\t\t\t\t\t<nc:has-preview />\n\t\t\t\t\t<nc:hidden />\n\t\t\t\t\t<oc:favorite />\n\t\t\t\t\t<oc:fileid />\n\t\t\t\t\t<oc:permissions />\n\t\t\t\t\t${extraProps.join('')}\n\t\t\t\t</d:prop>\n\t\t\t</d:propfind>`;\n}\n\n/**\n * @param {string} path - Collections' root path.\n * @param {import('webdav').StatOptions} options - Options to forward to the webdav client.\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @param {import('webdav').WebDAVClient} client - The DAV client to use.\n * @return {Promise<Collection|null>}\n */\nexport async function fetchCollection(path, options) {\n  let extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let client = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultClient;\n  try {\n    const response = await client.stat(path, {\n      data: getCollectionDavRequest(extraProps),\n      details: true,\n      ...options\n    });\n    logger.debug('[Collections] Fetched a collection: ', {\n      data: response.data\n    });\n    return formatCollection(response.data);\n  } catch (error) {\n    if (error.code === 'ERR_CANCELED') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n *\n * @param {string} path - Collections' root path.\n * @param {import('webdav').StatOptions} options - Options to forward to the webdav client.\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @param {import('webdav').WebDAVClient} client - The DAV client to use.\n * @return {Promise<Collection[]>}\n */\nexport async function fetchCollections(path, options) {\n  let extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let client = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultClient;\n  try {\n    const response = await client.getDirectoryContents(path, {\n      data: getCollectionDavRequest(extraProps),\n      details: true,\n      ...options\n    });\n    logger.debug(`[Collections] Fetched ${response.data.length} collections: `, {\n      data: response.data\n    });\n    return response.data.filter(collection => collection.filename !== path).map(formatCollection);\n  } catch (error) {\n    if (error.code === 'ERR_CANCELED') {\n      return [];\n    }\n    throw error;\n  }\n}\n\n/**\n *\n * @param {object} rawCollection - An collection received from a webdav request.\n * @return {Collection}\n */\nfunction formatCollection(rawCollection) {\n  // Ensure that we have a proper collaborators array.\n  if (rawCollection.props.collaborators === undefined || rawCollection.props.collaborators === '') {\n    rawCollection.props.collaborators = [];\n  } else if (typeof rawCollection.props.collaborators.collaborator === 'object') {\n    if (Array.isArray(rawCollection.props.collaborators.collaborator)) {\n      rawCollection.props.collaborators = rawCollection.props.collaborators.collaborator;\n    } else {\n      rawCollection.props.collaborators = [rawCollection.props.collaborators.collaborator];\n    }\n  }\n\n  // Extract custom props.\n  rawCollection = genFileInfo(rawCollection);\n\n  // Compute date range label.\n  const dateRange = JSON.parse(rawCollection.dateRange?.replace(/&quot;/g, '\"') ?? '{}');\n  if (dateRange.start === null) {\n    dateRange.start = moment().unix();\n    dateRange.end = moment().unix();\n  }\n  const dateRangeFormatted = {\n    startDate: moment.unix(dateRange.start).format('MMMM YYYY'),\n    endDate: moment.unix(dateRange.end).format('MMMM YYYY')\n  };\n  if (dateRangeFormatted.startDate === dateRangeFormatted.endDate) {\n    rawCollection.date = dateRangeFormatted.startDate;\n  } else {\n    rawCollection.date = t('photos', '{startDate} to {endDate}', dateRangeFormatted);\n  }\n  return rawCollection;\n}\n\n/**\n *\n * @param {string} path - Collections' root path.\n * @param {import('webdav').StatOptions} options - Options to forward to the webdav client.\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @param {import('webdav').WebDAVClient} client - The DAV client to use.\n * @return {Promise<CollectionFile[]>}\n */\nexport async function fetchCollectionFiles(path, options) {\n  let extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let client = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultClient;\n  try {\n    const response = await client.getDirectoryContents(path, {\n      data: getCollectionFilesDavRequest(extraProps),\n      details: true,\n      ...options\n    });\n    const fetchedFiles = response.data.map(file => genFileInfo(file)).filter(file => file.fileid);\n    logger.debug(`[Collections] Fetched ${fetchedFiles.length} new files: `, fetchedFiles);\n    return fetchedFiles;\n  } catch (error) {\n    if (error.code === 'ERR_CANCELED') {\n      return [];\n    }\n    logger.error('Error fetching collection files', {\n      error\n    });\n    console.error(error);\n    throw error;\n  }\n}"],"names":[],"sourceRoot":""}